#lang racket

; (provide append-line
;          get-c-string
;          convert-id-to-c)

(provide (all-defined-out))

(define (get-c-string s)
  (string->symbol (convert-id-to-c s)))

; appends a line in the program, default mode is append, if not specified
(define (append-line filename line [mode 'append])
  (define outfile (open-output-file #:exists mode filename))

  (displayln line outfile)

  (close-output-port outfile))

; appends a list of lines in the program
(define (append-list-to-file filename lst [mode 'append])
  (define outfile (open-output-file #:exists mode filename))

  (for ([item lst])
    (displayln item outfile))

  (close-output-port outfile))

; Takes a symbol as input and returns a string that represents a C-compatible identifier
(define (convert-id-to-c sym)
  (foldr string-append
         (string-append)
         (map (Î» (ch)
                (cond
                  [(or (char-alphabetic? ch) (char-numeric? ch) (eq? ch #\_)) (string ch)]
                  [else (string-append "_u" (number->string (char->integer ch)))]))
              (string->list (symbol->string sym)))))

(define (print-color text color)
  (display "\x1b[")
  (display color)
  (display "m")
  (display text)
  (display "\x1b[0m"))

(define (print-red text)
  (print-color text "31"))

(define (print-green text)
  (print-color text "32"))

(define (write-to-c file content)
  (with-output-to-file file (lambda () (display content)) #:exists 'replace))

(define (verify-correctness file desugar alphatize anf cps closure)
  (cond
    [(and (equal? desugar alphatize) (equal? alphatize anf) (equal? anf cps) (equal? cps closure))
     (print-green "Each output stage matched!")
     (displayln "\n")]
    [else
     (print-red "Your outputs did not match for")
     (display (~a file "\n"))]))

(define (verify-dir out-dir)
  (unless (directory-exists? out-dir)
    (pretty-print out-dir)
    (make-directory out-dir)))

; This is still in testing
(define (verify-answer-file answer-file)
  (unless (file-exists? answer-file)
    (displayln "Outputting necessary answer file")
    (write-to-c answer-file "")))

(define (verify-cmake cmake-file)
  (unless (file-exists? cmake-file)
    (displayln "Outputting necessary CMakeLists.txt file")
    (write-to-c
     cmake-file
     "# variable for ../ and ../../ directories

      cmake_path(GET CMAKE_CURRENT_SOURCE_DIR PARENT_PATH testing_dir)
      cmake_path(GET testing_dir PARENT_PATH main_dir)

      get_filename_component(TEST_NAME ${CMAKE_CURRENT_SOURCE_DIR} NAME)
      # linking gtest
      add_library(GTest::GTest INTERFACE IMPORTED)
      target_link_libraries(GTest::GTest INTERFACE gtest_main)

      # executable for the code generated by the emit-cpp.rkt
      add_executable(${TEST_NAME}_exec ${CMAKE_CURRENT_SOURCE_DIR}/compiler-out/${TEST_NAME}_cpp_program.cpp)
      target_link_libraries(${TEST_NAME}_exec
      PRIVATE
      prelude)

      # executable for the test driver
      add_executable(${TEST_NAME}_test driver.cpp)
      target_include_directories(${TEST_NAME}_test PUBLIC ${main_dir} ${testing_dir})
      target_link_libraries(${TEST_NAME}_test
      PRIVATE
      GTest::GTest
      prelude
      testing)

      # adds a test to be tracked by the cmake
      add_test(${TEST_NAME}_test ${TEST_NAME}_test)")))

(define (verify-driver driver-file)
  (unless (file-exists? driver-file)
    (displayln "Outputting the necessary C++ driver file")
    (write-to-c
     driver-file
     "#include <prelude.hpp>
        #include <testing.hpp>
        #include <filesystem>
        #include <gtest/gtest.h>
        #include <iostream>

        std::string getCurrentDirectory() {
            return std::filesystem::path(__FILE__).parent_path().filename();
        }

        std::string constructRelativePath(const std::string& subpath) {
            return \"../../../tests/\" + getCurrentDirectory() + \"/\" + subpath;
        }

        TEST(and_Test, desugar)
        {
            std::string answer = readFileToString(constructRelativePath(\"answer\"));
            std::string desugar_res = readFileToString(constructRelativePath(\"output/and_alphatize_res.out\"));
            ASSERT_EQ(answer, desugar_res);
        }

        TEST(and_Test, alphatize)
        {
            std::string answer = readFileToString(constructRelativePath(\"answer\"));
            std::string alphatize_res = readFileToString(constructRelativePath(\"output/and_alphatize_res.out\"));
            ASSERT_EQ(answer, alphatize_res);
        }

        TEST(and_Test, anf)
        {
            std::string answer = readFileToString(constructRelativePath(\"answer\"));
            std::string anf_res = readFileToString(constructRelativePath(\"output/and_anf_res.out\"));
            ASSERT_EQ(answer, anf_res);
        }

        TEST(and_Test, closure)
        {
            std::string answer = readFileToString(constructRelativePath(\"answer\"));
            std::string closure_res = readFileToString(constructRelativePath(\"output/and_closure_res.out\"));
            ASSERT_EQ(answer, closure_res);
        }

        TEST(and_Test, cps)
        {
            std::string answer = readFileToString(constructRelativePath(\"answer\"));
            std::string cps_res = readFileToString(constructRelativePath(\"output/and_cps_res.out\"));
            ASSERT_EQ(answer, cps_res);
        }

        TEST(and_Test, CPP_test)
        {
            std::string answer = readFileToString(constructRelativePath(\"answer\"));
            std::string output = executeAndGetOutput(\"./and_exec\");
            writeStringToFile(constructRelativePath(\"output/and_cpp_res.out\"), output);
            ASSERT_EQ(answer, output);
        }

        int main(int argc, char** argv)
        {
            ::testing::InitGoogleTest(&argc, argv);
            return RUN_ALL_TESTS();
        }
        ")))
; end further testing section

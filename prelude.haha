; Prelude is used as a way to add functionality to the language and programs as a library

(define (+ . lst)
  (apply-prim + lst))

(define (- . lst)
  (apply-prim - lst))
; To add a length function here

(define (* . lst)
  (apply-prim * lst))

(define (modulo a b)
  (prim modulo a b))

; (define (/ . lst)
;    (apply-prim / lst))

(define (= . lst)
  (apply-prim = lst))

(define (> . lst)
  (apply-prim > lst))

(define (< . lst)
  (apply-prim < lst))

(define (<= . lst)
  (apply-prim <= lst))

(define (>= . lst)
  (apply-prim >= lst))

(define (null? x)
  (prim null? x))

(define (equal? x y)
  (prim equal? x y))

(define (eq? x y)
  (prim eq? x y))

(define (cons a b)
  (prim cons a b))

(define (car lst)
  (prim car lst))

(define (cdr lst)
  (prim cdr lst))

(define (even? x)
  (equal? 0 (modulo x 2)))

(define (odd? x)
  (equal? 1 (modulo x 2)))

(define (list . x)
  x)


(define (member? x lst)
  (if (null? lst) #f (if (equal? (car lst) x) #t (member? x (cdr lst)))))

(define (foldl fun acc lst)
  (if (null? lst) acc (foldl fun (fun (car lst) acc) (cdr lst))))

(define (reverse lst lst2)
  (if (null? lst) lst2 (reverse (cdr lst) (cons (car lst) lst2))))

(define (take lst n lst2)
  (if (= n 0) lst2 (cons (car lst) (take (cdr lst) (- n 1) lst2))))

(define (length lst)
  (if (null? lst) 0 (+ 1 (length (cdr lst)))))

(define (map proc lst lst2)
  (if (null? lst) lst2 (cons (proc (car lst)) (map proc (cdr lst)))))

(define (filter op lst)
  (if (null? lst)
      (list)
      (if (op (car lst))
          (cons (car lst) (filter op (cdr lst)))
          (filter op (cdr lst)))))

(define (drop lst n)
  (if (= n 0) lst (drop (cdr lst) (- n 1))))

(define (foldr proc acc lst)
  (if (null? lst) acc
      (proc (car lst) (foldr proc acc (cdr lst)))))


; hash-prims to support
; (prim hash) // takes in a list of key and value pairs (hash k1 v1 k2 v2 ...) and makes a hash
; (prim hash-ref h k) // takes in a hash and a key and returns the value
; (prim hash-set h k v) // takes in a hash and a key and a value and update or insert the key
; (prim hash-keys h) // gets a cons list of keys
; (prim hash-has-key? h k) //takes a hash and a key and checks if it is there
; (prim hash-count h) // returns the count of keys hashed in the hash provided
; interfaces expected defined on https://docs.racket-lang.org/reference/hashtables.html#

(define (hash . lst)
   (apply-prim hash lst))

(define (hash-ref h k)
   (prim hash-ref h k))

(define (hash-set h k v)
   (prim hash-set h k v))

(define (hash-keys h)
   (prim hash-keys h))

(define (hash-has-key? h k)
   (prim hash-has-key? h k))


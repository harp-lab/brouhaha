#lang racket

(require "compile.rkt"
         "utils.rkt"
         "interp-anf.rkt"
         "interp-cps.rkt"
         "interp-closure.rkt"
         "emit-cpp.rkt"
         "emit-slog.rkt")

(define (print-color text color)
  (display "\x1b[")
  (display color)
  (display "m")
  (display text)
  (display "\x1b[0m"))

(define (print-red text)
  (print-color text "31"))

(define (print-green text)
  (print-color text "32"))

(define (write-to file content)
  (with-output-to-file file (lambda () (pretty-print content)) #:exists 'replace))

(define (write-to-c file content)
  (with-output-to-file file (lambda () (display content)) #:exists 'replace))

(define (verify-correctness file desugar alphatize anf cps closure)
  (cond
    [(and (equal? desugar alphatize) (equal? alphatize anf) (equal? anf cps) (equal? cps closure))
     (print-green "Each output stage matched!")
     (displayln "\n")]
    [else
     (print-red "Your outputs did not match for")
     (display (~a file "\n"))]))

(define (verify-dir out-dir)
  (unless (directory-exists? out-dir)
    (pretty-print out-dir)
    (make-directory out-dir)))

; This is still in testing
(define (verify-cmake cmake-file)
  (unless (file-exists? cmake-file)
    (displayln "Outputting necessary CMakeLists.txt file")
    (write-to-c
     cmake-file
     "# variable for ../ and ../../ directories

      cmake_path(GET CMAKE_CURRENT_SOURCE_DIR PARENT_PATH testing_dir)
      cmake_path(GET testing_dir PARENT_PATH main_dir)

      get_filename_component(TEST_NAME ${CMAKE_CURRENT_SOURCE_DIR} NAME)
      # linking gtest
      add_library(GTest::GTest INTERFACE IMPORTED)
      target_link_libraries(GTest::GTest INTERFACE gtest_main)

      # executable for the code generated by the emit-cpp.rkt
      add_executable(${TEST_NAME}_exec ${CMAKE_CURRENT_SOURCE_DIR}/compiler-out/${TEST_NAME}_cpp_program.cpp)
      target_link_libraries(${TEST_NAME}_exec
      PRIVATE
      prelude)

      # executable for the test driver
      add_executable(${TEST_NAME}_test driver.cpp)
      target_include_directories(${TEST_NAME}_test PUBLIC ${main_dir} ${testing_dir})
      target_link_libraries(${TEST_NAME}_test
      PRIVATE
      GTest::GTest
      prelude
      testing)

      # adds a test to be tracked by the cmake
      add_test(${TEST_NAME}_test ${TEST_NAME}_test)")))

(define (run-program directory program filename file-path prelude-path)
  (with-handlers ([exn:fail?
                   (lambda (exn)
                     (displayln
                      (~a "Now running: " filename "\n" "Failed to run: " filename " with error "))
                     (print-red (exn-message exn))
                     (displayln "\n"))])

    (define filename-string-ext
      (path->string filename)) ; converting  #<path:apply.haha> to "apply.haha"
    (define filename-string
      (regexp-replace #rx"[.]haha$" filename-string-ext "")) ; fname wo extension
    (define out-dir (string-append directory "/" filename-string)) ; "tests2/" + "apply"

    (verify-cmake (string-append out-dir "/CMakeLists.txt"))

    (let* ([generate-res-filepath
            (lambda (suffix) (string-append out-dir "/output/" filename-string suffix))]
           [generate-comp-filepath
            (lambda (suffix) (string-append out-dir "/compiler-out/" filename-string suffix))]
           [compiled-program (compile (append (read-program prelude-path) (read-program file-path)))]
           [desugar_prg (list-ref compiled-program 0)]
           [alphatize_prg (list-ref compiled-program 1)]
           [anf_prg (list-ref compiled-program 2)]
           [cps_prg (list-ref compiled-program 3)]
           [cps_after_anf (list-ref compiled-program 4)]
           [clo_conv_prg (list-ref compiled-program 5)]
           [results (list (interp desugar_prg)
                          (interp alphatize_prg)
                          (interp anf_prg)
                          (interp-cps cps_prg)
                          (interp-closure clo_conv_prg))])

      (verify-dir out-dir)
      (verify-dir (string-append out-dir "/output/"))
      (verify-dir (string-append out-dir "/compiler-out/"))
      (displayln (~a "Now running: " filename-string))

      (displayln (~a "Emitting C++ for: "
                     filename-string
                     " and outputting to: "
                     (generate-comp-filepath "_cpp_program.cpp")))
      (emit-cpp clo_conv_prg (generate-comp-filepath "_cpp_program.cpp"))

      ; (displayln (~a "Emitting Slog for: "
      ;                filename-string
      ;                " and outputting to: "
      ;                (generate-filepath "_slog.slog")))
      ; ; (write-to (generate-filepath "_slog.slog") (write-program-for-slog desugar_prg))
      ; (with-output-to-file (generate-filepath "_slog.slog") (lambda () (pretty-print (write-program-for-slog desugar_prg))) #:exists 'replace)

      (for-each
       write-to
       (map
        generate-comp-filepath
        (list "_compile.out" "_desugar.out" "_alphatize.out" "_anf.out" "_cps.out" "_closure.out"))
       compiled-program)
      (for-each write-to
                (map generate-res-filepath
                     (list "_desugar_res.out"
                           "_alphatize_res.out"
                           "_anf_res.out"
                           "_cps_res.out"
                           "_closure_res.out"))
                results)
      (apply verify-correctness (cons filename-string results)))))

(define (read-direc directory)
  (for-each (lambda (dir)
              (let ([dir-path (build-path (current-directory) directory dir)])
                (when (directory-exists? dir-path)
                  (for-each (lambda (file)
                              (let ([file-path (build-path (current-directory) directory dir file)])
                                (when (and (file-exists? file-path)
                                           (regexp-match? #rx"[.]haha$" (path->string file)))
                                  (run-program directory
                                               (read-program file-path)
                                               file
                                               file-path
                                               (build-path (current-directory) "prelude.haha")))))
                            (directory-list (build-path (current-directory) directory dir))))))
            (directory-list directory)))

(define (test-file user-file)
  (define direc (regexp-replace #rx"[A-Za-z0-9]+\\.haha$" user-file ""))
  (let ([full-path (build-path (current-directory) user-file)])
    (run-program direc
                 (read-program full-path)
                 (string->path "\\")
                 full-path
                 (build-path (current-directory) "prelude.haha"))))

(define (main args)
  (cond
    [(= (vector-length args) 0) (read-direc "tests/")]
    [(and (= (vector-length args) 1) (directory-exists? (vector-ref args 0)))
     (read-direc (vector-ref args 0))]
    [(and (= (vector-length args) 1) (file-exists? (vector-ref args 0)))
     (test-file (vector-ref args 0))]
    [else (error "Invalid command line arguments. Please provide either a file or a directory.")]))

(main (current-command-line-arguments))

'((define (+ . lst) (let ((x6599 (apply-prim + lst))) x6599))
  (define (- . lst) (let ((x6600 (apply-prim - lst))) x6600))
  (define (* . lst) (let ((x6601 (apply-prim * lst))) x6601))
  (define (modulo a b) (let ((x6602 (prim modulo a b))) x6602))
  (define (/ . lst) (let ((x6603 (apply-prim / lst))) x6603))
  (define (= . lst) (let ((x6604 (apply-prim = lst))) x6604))
  (define (> . lst) (let ((x6605 (apply-prim > lst))) x6605))
  (define (< . lst) (let ((x6606 (apply-prim < lst))) x6606))
  (define (<= . lst) (let ((x6607 (apply-prim <= lst))) x6607))
  (define (>= . lst) (let ((x6608 (apply-prim >= lst))) x6608))
  (define (null? x) (let ((x6609 (prim null? x))) x6609))
  (define (equal? x y) (let ((x6610 (prim equal? x y))) x6610))
  (define (eq? x y) (let ((x6611 (prim eq? x y))) x6611))
  (define (cons a b) (let ((x6612 (prim cons a b))) x6612))
  (define (car lst) (let ((x6613 (prim car lst))) x6613))
  (define (cdr lst) (let ((x6614 (prim cdr lst))) x6614))
  (define (even? x)
    (let ((a6615 '0))
      (let ((a6616 '2))
        (let ((a6617 (modulo x a6616))) (equal? a6615 a6617)))))
  (define (odd? x)
    (let ((a6618 '1))
      (let ((a6619 '2))
        (let ((a6620 (modulo x a6619))) (equal? a6618 a6620)))))
  (define (list . x) x)
  (define (member? x lst)
    (let ((a6621 (null? lst)))
      (if a6621
        (let ((x6622 '#f)) x6622)
        (let ((a6623 (car lst)))
          (let ((a6624 (equal? a6623 x)))
            (if a6624
              (let ((x6625 '#t)) x6625)
              (let ((a6626 (cdr lst))) (member? x a6626))))))))
  (define (foldl fun acc lst)
    (let ((a6627 (null? lst)))
      (if a6627
        acc
        (let ((a6628 (car lst)))
          (let ((a6629 (fun a6628 acc)))
            (let ((a6630 (cdr lst))) (foldl fun a6629 a6630)))))))
  (define (reverse-helper lst lst2)
    (let ((a6631 (null? lst)))
      (if a6631
        lst2
        (let ((a6632 (cdr lst)))
          (let ((a6633 (car lst)))
            (let ((a6634 (cons a6633 lst2))) (reverse-helper a6632 a6634)))))))
  (define (reverse lst) (let ((a6635 (list))) (reverse-helper lst a6635)))
  (define (take-helper lst n lst2)
    (let ((a6636 '0))
      (let ((a6637 (= n a6636)))
        (if a6637
          (let ((x6638 (reverse lst2))) x6638)
          (let ((a6639 (cdr lst)))
            (let ((a6640 '1))
              (let ((a6641 (- n a6640)))
                (let ((a6642 (car lst)))
                  (let ((a6643 (cons a6642 lst2)))
                    (take-helper a6639 a6641 a6643))))))))))
  (define (take lst n) (let ((a6644 (list))) (take-helper lst n a6644)))
  (define (length lst)
    (let ((a6645 (null? lst)))
      (if a6645
        (let ((x6646 '0)) x6646)
        (let ((a6647 '1))
          (let ((a6648 (cdr lst)))
            (let ((a6649 (length a6648))) (+ a6647 a6649)))))))
  (define (map proc lst)
    (let ((a6650 (null? lst)))
      (if a6650
        (let ((x6651 (list))) x6651)
        (let ((a6652 (car lst)))
          (let ((a6653 (proc a6652)))
            (let ((a6654 (cdr lst)))
              (let ((a6655 (map proc a6654))) (cons a6653 a6655))))))))
  (define (filter op lst)
    (let ((a6656 (null? lst)))
      (if a6656
        (let ((x6657 (list))) x6657)
        (let ((a6658 (car lst)))
          (let ((a6659 (op a6658)))
            (if a6659
              (let ((a6660 (car lst)))
                (let ((a6661 (cdr lst)))
                  (let ((a6662 (filter op a6661))) (cons a6660 a6662))))
              (let ((a6663 (cdr lst))) (filter op a6663))))))))
  (define (drop lst n)
    (let ((a6664 '0))
      (let ((a6665 (= n a6664)))
        (if a6665
          lst
          (let ((a6666 (cdr lst)))
            (let ((a6667 '1))
              (let ((a6668 (- n a6667))) (drop a6666 a6668))))))))
  (define (foldr proc acc lst)
    (let ((a6669 (null? lst)))
      (if a6669
        acc
        (let ((a6670 (car lst)))
          (let ((a6671 (cdr lst)))
            (let ((a6672 (foldr proc acc a6671))) (proc a6670 a6672)))))))
  (define (append lst1 lst2)
    (let ((a6673 (null? lst1)))
      (if a6673
        lst2
        (let ((a6674 (car lst1)))
          (let ((a6675 (cdr lst1)))
            (let ((a6676 (append a6675 lst2))) (cons a6674 a6676)))))))
  (define (hash . lst) (let ((x6677 (apply-prim hash lst))) x6677))
  (define (hash-ref h k) (let ((x6678 (prim hash-ref h k))) x6678))
  (define (hash-set h k v) (let ((x6679 (prim hash-set h k v))) x6679))
  (define (hash-has-key? h k) (let ((x6680 (prim hash-has-key? h k))) x6680))
  (define (hash-count h) (let ((x6681 (prim hash-count h))) x6681))
  (define (helper i count num)
    (let ((a6682 (> i num)))
      (if a6682
        count
        (let ((a6683 '1))
          (let ((a6684 (+ i a6683)))
            (let ((a6685 (modulo num i)))
              (let ((a6686 '0))
                (let ((a6687 (= a6685 a6686)))
                  (let ((a6689
                         (if a6687 (let ((a6688 '1)) (+ count a6688)) count)))
                    (helper a6684 a6689 num))))))))))
  (define (count-divisors num)
    (let ((a6690 '1)) (let ((a6691 '0)) (helper a6690 a6691 num))))
  (define (brouhaha_main) (let ((a6692 '10)) (count-divisors a6692))))

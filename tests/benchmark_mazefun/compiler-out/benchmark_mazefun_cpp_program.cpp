#include<stdio.h>
#include<string.h>
#include "gmp_func.h"
#include "../../prelude.hpp"

// declaring global constants at the top
void* int9475;
void* int9452;
void* bool_t9470;
void* int9468;
void* bool_f9473;
void* int9426;
void* int9477;
void* int9450;
void* int9451;



// declaring functions at the top
void _u43_fptr(); // +
void* _u43 = encode_clo(alloc_clo(_u43_fptr, 0));

void _u45_fptr(); // -
void* _u45 = encode_clo(alloc_clo(_u45_fptr, 0));

void _u42_fptr(); // *
void* _u42 = encode_clo(alloc_clo(_u42_fptr, 0));

void _u47_fptr(); // /
void* _u47 = encode_clo(alloc_clo(_u47_fptr, 0));

void _u61_fptr(); // =
void* _u61 = encode_clo(alloc_clo(_u61_fptr, 0));

void _u62_fptr(); // >
void* _u62 = encode_clo(alloc_clo(_u62_fptr, 0));

void _u60_fptr(); // <
void* _u60 = encode_clo(alloc_clo(_u60_fptr, 0));

void _u60_u61_fptr(); // <=
void* _u60_u61 = encode_clo(alloc_clo(_u60_u61_fptr, 0));

void _u62_u61_fptr(); // >=
void* _u62_u61 = encode_clo(alloc_clo(_u62_u61_fptr, 0));

void modulo_fptr(); // modulo
void* modulo = encode_clo(alloc_clo(modulo_fptr, 0));

void null_u63_fptr(); // null?
void* null_u63 = encode_clo(alloc_clo(null_u63_fptr, 0));

void equal_u63_fptr(); // equal?
void* equal_u63 = encode_clo(alloc_clo(equal_u63_fptr, 0));

void eq_u63_fptr(); // eq?
void* eq_u63 = encode_clo(alloc_clo(eq_u63_fptr, 0));

void cons_fptr(); // cons
void* cons = encode_clo(alloc_clo(cons_fptr, 0));

void car_fptr(); // car
void* car = encode_clo(alloc_clo(car_fptr, 0));

void cdr_fptr(); // cdr
void* cdr = encode_clo(alloc_clo(cdr_fptr, 0));

void float_u45_u62int_fptr(); // float->int
void* float_u45_u62int = encode_clo(alloc_clo(float_u45_u62int_fptr, 0));

void int_u45_u62float_fptr(); // int->float
void* int_u45_u62float = encode_clo(alloc_clo(int_u45_u62float_fptr, 0));

void hash_fptr(); // hash
void* hash = encode_clo(alloc_clo(hash_fptr, 0));

void hash_u45ref_fptr(); // hash-ref
void* hash_u45ref = encode_clo(alloc_clo(hash_u45ref_fptr, 0));

void hash_u45set_fptr(); // hash-set
void* hash_u45set = encode_clo(alloc_clo(hash_u45set_fptr, 0));

void hash_u45keys_fptr(); // hash-keys
void* hash_u45keys = encode_clo(alloc_clo(hash_u45keys_fptr, 0));

void hash_u45has_u45key_u63_fptr(); // hash-has-key?
void* hash_u45has_u45key_u63 = encode_clo(alloc_clo(hash_u45has_u45key_u63_fptr, 0));

void hash_u45count_fptr(); // hash-count
void* hash_u45count = encode_clo(alloc_clo(hash_u45count_fptr, 0));

void set_fptr(); // set
void* set = encode_clo(alloc_clo(set_fptr, 0));

void set_u45_u62list_fptr(); // set->list
void* set_u45_u62list = encode_clo(alloc_clo(set_u45_u62list_fptr, 0));

void list_u45_u62set_fptr(); // list->set
void* list_u45_u62set = encode_clo(alloc_clo(list_u45_u62set_fptr, 0));

void set_u45add_fptr(); // set-add
void* set_u45add = encode_clo(alloc_clo(set_u45add_fptr, 0));

void set_u45member_u63_fptr(); // set-member?
void* set_u45member_u63 = encode_clo(alloc_clo(set_u45member_u63_fptr, 0));

void set_u45remove_fptr(); // set-remove
void* set_u45remove = encode_clo(alloc_clo(set_u45remove_fptr, 0));

void set_u45count_fptr(); // set-count
void* set_u45count = encode_clo(alloc_clo(set_u45count_fptr, 0));

void string_u63_fptr(); // string?
void* string_u63 = encode_clo(alloc_clo(string_u63_fptr, 0));

void string_u45length_fptr(); // string-length
void* string_u45length = encode_clo(alloc_clo(string_u45length_fptr, 0));

void string_u45ref_fptr(); // string-ref
void* string_u45ref = encode_clo(alloc_clo(string_u45ref_fptr, 0));

void substring_fptr(); // substring
void* substring = encode_clo(alloc_clo(substring_fptr, 0));

void string_u45append_fptr(); // string-append
void* string_u45append = encode_clo(alloc_clo(string_u45append_fptr, 0));

void string_u45_u62list_fptr(); // string->list
void* string_u45_u62list = encode_clo(alloc_clo(string_u45_u62list_fptr, 0));

void exact_u45floor_fptr(); // exact-floor
void* exact_u45floor = encode_clo(alloc_clo(exact_u45floor_fptr, 0));

void exact_u45ceiling_fptr(); // exact-ceiling
void* exact_u45ceiling = encode_clo(alloc_clo(exact_u45ceiling_fptr, 0));

void exact_u45round_fptr(); // exact-round
void* exact_u45round = encode_clo(alloc_clo(exact_u45round_fptr, 0));

void abs_fptr(); // abs
void* abs_brouhaha = encode_clo(alloc_clo(abs_fptr, 0));

void max_fptr(); // max
void* max = encode_clo(alloc_clo(max_fptr, 0));

void min_fptr(); // min
void* min = encode_clo(alloc_clo(min_fptr, 0));

void expt_fptr(); // expt
void* expt = encode_clo(alloc_clo(expt_fptr, 0));

void sqrt_fptr(); // sqrt
void* sqrt_brouhaha = encode_clo(alloc_clo(sqrt_fptr, 0));

void remainder_fptr(); // remainder
void* remainder_brouhaha = encode_clo(alloc_clo(remainder_fptr, 0));

void quotient_fptr(); // quotient
void* quotient = encode_clo(alloc_clo(quotient_fptr, 0));

void random_fptr(); // random
void* random_brouhaha = encode_clo(alloc_clo(random_fptr, 0));

void symbol_u63_fptr(); // symbol?
void* symbol_u63 = encode_clo(alloc_clo(symbol_u63_fptr, 0));

void pair_u63_fptr(); // pair?
void* pair_u63 = encode_clo(alloc_clo(pair_u63_fptr, 0));

void positive_u63_fptr(); // positive?
void* positive_u63 = encode_clo(alloc_clo(positive_u63_fptr, 0));

void negative_u63_fptr(); // negative?
void* negative_u63 = encode_clo(alloc_clo(negative_u63_fptr, 0));

void list_fptr(); // list
void* list = encode_clo(alloc_clo(list_fptr, 0));

void even_u63_fptr(); // even?
void even_u63_spec(void* _9221, void* kont9096, void* x); // even?
void* even_u63 = encode_clo(alloc_clo(even_u63_fptr, 0));

void odd_u63_fptr(); // odd?
void odd_u63_spec(void* _9222, void* kont9097, void* x); // odd?
void* odd_u63 = encode_clo(alloc_clo(odd_u63_fptr, 0));

void list_u45ref_fptr(); // list-ref
void list_u45ref_spec(void* _9223, void* kont9098, void* lst, void* n); // list-ref
void* list_u45ref = encode_clo(alloc_clo(list_u45ref_fptr, 0));

void lam9224_fptr(); // lam9224
void lam9224_spec(void* env9225, void* id_8745); // lam9224
void* lam9224 = encode_clo(alloc_clo(lam9224_fptr, 0));

void member_fptr(); // member
void member_spec(void* _9226, void* kont9099, void* item, void* lst); // member
void* member = encode_clo(alloc_clo(member_fptr, 0));

void member_u63_fptr(); // member?
void member_u63_spec(void* _9227, void* kont9101, void* x, void* lst); // member?
void* member_u63 = encode_clo(alloc_clo(member_u63_fptr, 0));

void lam9228_fptr(); // lam9228
void lam9228_spec(void* env9229, void* id_8760); // lam9228
void* lam9228 = encode_clo(alloc_clo(lam9228_fptr, 0));

void length_fptr(); // length
void length_spec(void* _9230, void* kont9102, void* lst); // length
void* length = encode_clo(alloc_clo(length_fptr, 0));

void lam9231_fptr(); // lam9231
void lam9231_spec(void* env9232, void* id_8766); // lam9231
void* lam9231 = encode_clo(alloc_clo(lam9231_fptr, 0));

void lam9233_fptr(); // lam9233
void lam9233_spec(void* env9234, void* id_8764); // lam9233
void* lam9233 = encode_clo(alloc_clo(lam9233_fptr, 0));

void map_fptr(); // map
void map_spec(void* _9235, void* kont9104, void* proc, void* lst); // map
void* map = encode_clo(alloc_clo(map_fptr, 0));

void lam9236_fptr(); // lam9236
void lam9236_spec(void* env9237, void* id_8773); // lam9236
void* lam9236 = encode_clo(alloc_clo(lam9236_fptr, 0));

void lam9238_fptr(); // lam9238
void lam9238_spec(void* env9239, void* id_8770); // lam9238
void* lam9238 = encode_clo(alloc_clo(lam9238_fptr, 0));

void filter_fptr(); // filter
void filter_spec(void* _9240, void* kont9107, void* op, void* lst); // filter
void* filter = encode_clo(alloc_clo(filter_fptr, 0));

void drop_fptr(); // drop
void drop_spec(void* _9241, void* kont9110, void* lst, void* n); // drop
void* drop = encode_clo(alloc_clo(drop_fptr, 0));

void lam9242_fptr(); // lam9242
void lam9242_spec(void* env9243, void* id_8782); // lam9242
void* lam9242 = encode_clo(alloc_clo(lam9242_fptr, 0));

void foldl_fptr(); // foldl
void foldl_spec(void* _9244, void* kont9111, void* fun, void* acc, void* lst); // foldl
void* foldl = encode_clo(alloc_clo(foldl_fptr, 0));

void lam9245_fptr(); // lam9245
void lam9245_spec(void* env9246, void* id_8787); // lam9245
void* lam9245 = encode_clo(alloc_clo(lam9245_fptr, 0));

void foldr_fptr(); // foldr
void foldr_spec(void* _9247, void* kont9113, void* fun, void* acc, void* lst); // foldr
void* foldr = encode_clo(alloc_clo(foldr_fptr, 0));

void reverse_u45helper_fptr(); // reverse-helper
void reverse_u45helper_spec(void* _9248, void* kont9115, void* lst, void* lst2); // reverse-helper
void* reverse_u45helper = encode_clo(alloc_clo(reverse_u45helper_fptr, 0));

void reverse_fptr(); // reverse
void reverse_spec(void* _9249, void* kont9116, void* lst); // reverse
void* reverse = encode_clo(alloc_clo(reverse_fptr, 0));

void lam9250_fptr(); // lam9250
void lam9250_spec(void* env9251, void* id_8796); // lam9250
void* lam9250 = encode_clo(alloc_clo(lam9250_fptr, 0));

void append1_fptr(); // append1
void append1_spec(void* _9252, void* kont9117, void* lhs, void* rhs); // append1
void* append1 = encode_clo(alloc_clo(append1_fptr, 0));

void lam9253_fptr(); // lam9253
void lam9253_spec(void* env9254, void* id_8803); // lam9253
void* lam9253 = encode_clo(alloc_clo(lam9253_fptr, 0));

void lam9255_fptr(); // lam9255
void lam9255_spec(void* env9256, void* id_8798); // lam9255
void* lam9255 = encode_clo(alloc_clo(lam9255_fptr, 0));

void lam9257_fptr(); // lam9257
void lam9257_spec(void* env9258, void* x); // lam9257
void* lam9257 = encode_clo(alloc_clo(lam9257_fptr, 0));

void append_fptr(); // append
void* append = encode_clo(alloc_clo(append_fptr, 0));

void lam9260_fptr(); // lam9260
void lam9260_spec(void* env9261, void* xy8806); // lam9260
void* lam9260 = encode_clo(alloc_clo(lam9260_fptr, 0));

void take_u45helper_fptr(); // take-helper
void take_u45helper_spec(void* _9262, void* kont9123, void* lst, void* n, void* lst2); // take-helper
void* take_u45helper = encode_clo(alloc_clo(take_u45helper_fptr, 0));

void take_fptr(); // take
void take_spec(void* _9263, void* kont9125, void* lst, void* n); // take
void* take = encode_clo(alloc_clo(take_fptr, 0));

void lam9264_fptr(); // lam9264
void lam9264_spec(void* env9265, void* id_8816); // lam9264
void* lam9264 = encode_clo(alloc_clo(lam9264_fptr, 0));

void my_u45foldr_u45aux_fptr(); // my-foldr-aux
void my_u45foldr_u45aux_spec(void* _9266, void* kont9126, void* lst, void* f, void* base); // my-foldr-aux
void* my_u45foldr_u45aux = encode_clo(alloc_clo(my_u45foldr_u45aux_fptr, 0));

void lam9267_fptr(); // lam9267
void lam9267_spec(void* env9268, void* xy8817); // lam9267
void* lam9267 = encode_clo(alloc_clo(lam9267_fptr, 0));

void my_u45foldr_fptr(); // my-foldr
void my_u45foldr_spec(void* _9269, void* kont9128, void* f, void* base, void* lst); // my-foldr
void* my_u45foldr = encode_clo(alloc_clo(my_u45foldr_fptr, 0));

void lam9270_fptr(); // lam9270
void lam9270_spec(void* env9271, void* id_8820); // lam9270
void* lam9270 = encode_clo(alloc_clo(lam9270_fptr, 0));

void my_u45foldl_u45aux_fptr(); // my-foldl-aux
void my_u45foldl_u45aux_spec(void* _9272, void* kont9130, void* f, void* base, void* lst); // my-foldl-aux
void* my_u45foldl_u45aux = encode_clo(alloc_clo(my_u45foldl_u45aux_fptr, 0));

void lam9273_fptr(); // lam9273
void lam9273_spec(void* env9274, void* xy8822); // lam9273
void* lam9273 = encode_clo(alloc_clo(lam9273_fptr, 0));

void my_u45foldl_fptr(); // my-foldl
void my_u45foldl_spec(void* _9275, void* kont9132, void* f, void* base, void* lst); // my-foldl
void* my_u45foldl = encode_clo(alloc_clo(my_u45foldl_fptr, 0));

void lam9276_fptr(); // lam9276
void lam9276_spec(void* env9277, void* id_8827); // lam9276
void* lam9276 = encode_clo(alloc_clo(lam9276_fptr, 0));

void lam9278_fptr(); // lam9278
void lam9278_spec(void* env9279, void* id_8824); // lam9278
void* lam9278 = encode_clo(alloc_clo(lam9278_fptr, 0));

void my_u45for_u45aux_fptr(); // my-for-aux
void my_u45for_u45aux_spec(void* _9280, void* kont9134, void* lo, void* hi, void* f); // my-for-aux
void* my_u45for_u45aux = encode_clo(alloc_clo(my_u45for_u45aux_fptr, 0));

void lam9281_fptr(); // lam9281
void lam9281_spec(void* env9282, void* xy8829); // lam9281
void* lam9281 = encode_clo(alloc_clo(lam9281_fptr, 0));

void my_u45for_fptr(); // my-for
void my_u45for_spec(void* _9283, void* kont9137, void* lo, void* hi, void* f); // my-for
void* my_u45for = encode_clo(alloc_clo(my_u45for_fptr, 0));

void concat_fptr(); // concat
void concat_spec(void* _9284, void* kont9139, void* lists); // concat
void* concat = encode_clo(alloc_clo(concat_fptr, 0));

void list_u45read_fptr(); // list-read
void list_u45read_spec(void* _9285, void* kont9140, void* lst, void* i); // list-read
void* list_u45read = encode_clo(alloc_clo(list_u45read_fptr, 0));

void lam9286_fptr(); // lam9286
void lam9286_spec(void* env9287, void* id_8844); // lam9286
void* lam9286 = encode_clo(alloc_clo(lam9286_fptr, 0));

void list_u45write_fptr(); // list-write
void list_u45write_spec(void* _9288, void* kont9141, void* lst, void* i, void* val); // list-write
void* list_u45write = encode_clo(alloc_clo(list_u45write_fptr, 0));

void lam9289_fptr(); // lam9289
void lam9289_spec(void* env9290, void* id_8852); // lam9289
void* lam9289 = encode_clo(alloc_clo(lam9289_fptr, 0));

void list_u45remove_u45pos_fptr(); // list-remove-pos
void list_u45remove_u45pos_spec(void* _9291, void* kont9143, void* lst, void* i); // list-remove-pos
void* list_u45remove_u45pos = encode_clo(alloc_clo(list_u45remove_u45pos_fptr, 0));

void lam9292_fptr(); // lam9292
void lam9292_spec(void* env9293, void* id_8857); // lam9292
void* lam9292 = encode_clo(alloc_clo(lam9292_fptr, 0));

void duplicates_u63_fptr(); // duplicates?
void duplicates_u63_spec(void* _9294, void* kont9145, void* lst); // duplicates?
void* duplicates_u63 = encode_clo(alloc_clo(duplicates_u63_fptr, 0));

void lam9295_fptr(); // lam9295
void lam9295_spec(void* env9296, void* cont9149, void* j); // lam9295
void* lam9295 = encode_clo(alloc_clo(lam9295_fptr, 0));

void lam9297_fptr(); // lam9297
void lam9297_spec(void* env9298, void* cont9148, void* i); // lam9297
void* lam9297 = encode_clo(alloc_clo(lam9297_fptr, 0));

void make_u45matrix_fptr(); // make-matrix
void make_u45matrix_spec(void* _9299, void* kont9147, void* n, void* m, void* init); // make-matrix
void* make_u45matrix = encode_clo(alloc_clo(make_u45matrix_fptr, 0));

void lam9300_fptr(); // lam9300
void lam9300_spec(void* env9301, void* id_8865); // lam9300
void* lam9300 = encode_clo(alloc_clo(lam9300_fptr, 0));

void matrix_u45read_fptr(); // matrix-read
void matrix_u45read_spec(void* _9302, void* kont9150, void* mat, void* i, void* j); // matrix-read
void* matrix_u45read = encode_clo(alloc_clo(matrix_u45read_fptr, 0));

void lam9303_fptr(); // lam9303
void lam9303_spec(void* env9304, void* id_8867); // lam9303
void* lam9303 = encode_clo(alloc_clo(lam9303_fptr, 0));

void lam9305_fptr(); // lam9305
void lam9305_spec(void* env9306, void* id_8866); // lam9305
void* lam9305 = encode_clo(alloc_clo(lam9305_fptr, 0));

void matrix_u45write_fptr(); // matrix-write
void matrix_u45write_spec(void* _9307, void* kont9152, void* mat, void* i, void* j, void* val); // matrix-write
void* matrix_u45write = encode_clo(alloc_clo(matrix_u45write_fptr, 0));

void lam9308_fptr(); // lam9308
void lam9308_spec(void* env9309, void* id_8870); // lam9308
void* lam9308 = encode_clo(alloc_clo(lam9308_fptr, 0));

void lam9310_fptr(); // lam9310
void lam9310_spec(void* env9311, void* id_8868); // lam9310
void* lam9310 = encode_clo(alloc_clo(lam9310_fptr, 0));

void matrix_u45size_fptr(); // matrix-size
void matrix_u45size_spec(void* _9312, void* kont9155, void* mat); // matrix-size
void* matrix_u45size = encode_clo(alloc_clo(matrix_u45size_fptr, 0));

void lam9313_fptr(); // lam9313
void lam9313_spec(void* env9314, void* cont9159, void* lst); // lam9313
void* lam9313 = encode_clo(alloc_clo(lam9313_fptr, 0));

void matrix_u45map_fptr(); // matrix-map
void matrix_u45map_spec(void* _9315, void* kont9158, void* f, void* mat); // matrix-map
void* matrix_u45map = encode_clo(alloc_clo(matrix_u45map_fptr, 0));

void initial_u45random_fptr(); // initial-random
void initial_u45random_spec(void* _9316, void* kont9160); // initial-random
void* initial_u45random = encode_clo(alloc_clo(initial_u45random_fptr, 0));

void next_u45random_fptr(); // next-random
void next_u45random_spec(void* _9317, void* kont9161, void* current_u45random); // next-random
void* next_u45random = encode_clo(alloc_clo(next_u45random_fptr, 0));

void lam9318_fptr(); // lam9318
void lam9318_spec(void* env9319, void* id_8880); // lam9318
void* lam9318 = encode_clo(alloc_clo(lam9318_fptr, 0));

void lam9320_fptr(); // lam9320
void lam9320_spec(void* env9321, void* id_8883); // lam9320
void* lam9320 = encode_clo(alloc_clo(lam9320_fptr, 0));

void lam9322_fptr(); // lam9322
void lam9322_spec(void* env9323, void* id_8882); // lam9322
void* lam9322 = encode_clo(alloc_clo(lam9322_fptr, 0));

void lam9324_fptr(); // lam9324
void lam9324_spec(void* env9325, void* id_8881); // lam9324
void* lam9324 = encode_clo(alloc_clo(lam9324_fptr, 0));

void lam9326_fptr(); // lam9326
void lam9326_spec(void* env9327, void* i); // lam9326
void* lam9326 = encode_clo(alloc_clo(lam9326_fptr, 0));

void lam9328_fptr(); // lam9328
void lam9328_spec(void* env9329, void* new_u45random); // lam9328
void* lam9328 = encode_clo(alloc_clo(lam9328_fptr, 0));

void shuffle_u45aux_fptr(); // shuffle-aux
void shuffle_u45aux_spec(void* _9330, void* kont9162, void* lst, void* current_u45random); // shuffle-aux
void* shuffle_u45aux = encode_clo(alloc_clo(shuffle_u45aux_fptr, 0));

void lam9331_fptr(); // lam9331
void lam9331_spec(void* env9332, void* id_8884); // lam9331
void* lam9331 = encode_clo(alloc_clo(lam9331_fptr, 0));

void shuffle_fptr(); // shuffle
void shuffle_spec(void* _9333, void* kont9169, void* lst); // shuffle
void* shuffle = encode_clo(alloc_clo(shuffle_fptr, 0));

void lam9334_fptr(); // lam9334
void lam9334_spec(void* env9335, void* cont9172, void* x); // lam9334
void* lam9334 = encode_clo(alloc_clo(lam9334_fptr, 0));

void cave_u45to_u45maze_fptr(); // cave-to-maze
void cave_u45to_u45maze_spec(void* _9336, void* kont9171, void* cave); // cave-to-maze
void* cave_u45to_u45maze = encode_clo(alloc_clo(cave_u45to_u45maze_fptr, 0));

void lam9337_fptr(); // lam9337
void lam9337_spec(void* env9338, void* id_8933); // lam9337
void* lam9337 = encode_clo(alloc_clo(lam9337_fptr, 0));

void lam9339_fptr(); // lam9339
void lam9339_spec(void* env9340, void* id_8928); // lam9339
void* lam9339 = encode_clo(alloc_clo(lam9339_fptr, 0));

void lam9341_fptr(); // lam9341
void lam9341_spec(void* env9342, void* id_8921); // lam9341
void* lam9341 = encode_clo(alloc_clo(lam9341_fptr, 0));

void lam9343_fptr(); // lam9343
void lam9343_spec(void* env9344, void* id_8916); // lam9343
void* lam9343 = encode_clo(alloc_clo(lam9343_fptr, 0));

void lam9345_fptr(); // lam9345
void lam9345_spec(void* env9346, void* id_8910); // lam9345
void* lam9345 = encode_clo(alloc_clo(lam9345_fptr, 0));

void lam9347_fptr(); // lam9347
void lam9347_spec(void* env9348, void* id_8905); // lam9347
void* lam9347 = encode_clo(alloc_clo(lam9347_fptr, 0));

void lam9349_fptr(); // lam9349
void lam9349_spec(void* env9350, void* id_8898); // lam9349
void* lam9349 = encode_clo(alloc_clo(lam9349_fptr, 0));

void lam9351_fptr(); // lam9351
void lam9351_spec(void* env9352, void* id_8893); // lam9351
void* lam9351 = encode_clo(alloc_clo(lam9351_fptr, 0));

void lam9353_fptr(); // lam9353
void lam9353_spec(void* env9354, void* size); // lam9353
void* lam9353 = encode_clo(alloc_clo(lam9353_fptr, 0));

void neighboring_u45cavities_fptr(); // neighboring-cavities
void neighboring_u45cavities_spec(void* _9355, void* kont9173, void* pos, void* cave); // neighboring-cavities
void* neighboring_u45cavities = encode_clo(alloc_clo(neighboring_u45cavities_fptr, 0));

void lam9356_fptr(); // lam9356
void lam9356_spec(void* env9357, void* id_8937); // lam9356
void* lam9356 = encode_clo(alloc_clo(lam9356_fptr, 0));

void lam9358_fptr(); // lam9358
void lam9358_spec(void* env9359, void* id_8936); // lam9358
void* lam9358 = encode_clo(alloc_clo(lam9358_fptr, 0));

void lam9360_fptr(); // lam9360
void lam9360_spec(void* env9361, void* cont9184, void* c, void* nc); // lam9360
void* lam9360 = encode_clo(alloc_clo(lam9360_fptr, 0));

void lam9362_fptr(); // lam9362
void lam9362_spec(void* env9363, void* cavity_u45id); // lam9362
void* lam9362 = encode_clo(alloc_clo(lam9362_fptr, 0));

void change_u45cavity_u45aux_fptr(); // change-cavity-aux
void change_u45cavity_u45aux_spec(void* _9364, void* kont9183, void* cave, void* pos, void* new_u45cavity_u45id, void* old_u45cavity_u45id); // change-cavity-aux
void* change_u45cavity_u45aux = encode_clo(alloc_clo(change_u45cavity_u45aux_fptr, 0));

void lam9365_fptr(); // lam9365
void lam9365_spec(void* env9366, void* id_8938); // lam9365
void* lam9365 = encode_clo(alloc_clo(lam9365_fptr, 0));

void change_u45cavity_fptr(); // change-cavity
void change_u45cavity_spec(void* _9367, void* kont9188, void* cave, void* pos, void* new_u45cavity_u45id); // change-cavity
void* change_u45cavity = encode_clo(alloc_clo(change_u45cavity_fptr, 0));

void pierce_fptr(); // pierce
void pierce_spec(void* _9368, void* kont9190, void* pos, void* cave); // pierce
void* pierce = encode_clo(alloc_clo(pierce_fptr, 0));

void lam9369_fptr(); // lam9369
void lam9369_spec(void* env9370, void* id_8945); // lam9369
void* lam9369 = encode_clo(alloc_clo(lam9369_fptr, 0));

void lam9371_fptr(); // lam9371
void lam9371_spec(void* env9372, void* cont9193, void* c, void* nc); // lam9371
void* lam9371 = encode_clo(alloc_clo(lam9371_fptr, 0));

void lam9373_fptr(); // lam9373
void lam9373_spec(void* env9374, void* id_8943); // lam9373
void* lam9373 = encode_clo(alloc_clo(lam9373_fptr, 0));

void lam9375_fptr(); // lam9375
void lam9375_spec(void* env9376, void* id_8942); // lam9375
void* lam9375 = encode_clo(alloc_clo(lam9375_fptr, 0));

void lam9377_fptr(); // lam9377
void lam9377_spec(void* env9378, void* cont9192, void* nc); // lam9377
void* lam9377 = encode_clo(alloc_clo(lam9377_fptr, 0));

void lam9379_fptr(); // lam9379
void lam9379_spec(void* env9380, void* ncs); // lam9379
void* lam9379 = encode_clo(alloc_clo(lam9379_fptr, 0));

void try_u45to_u45pierce_fptr(); // try-to-pierce
void try_u45to_u45pierce_spec(void* _9381, void* kont9191, void* pos, void* cave); // try-to-pierce
void* try_u45to_u45pierce = encode_clo(alloc_clo(try_u45to_u45pierce_fptr, 0));

void lam9382_fptr(); // lam9382
void lam9382_spec(void* env9383, void* id_8948); // lam9382
void* lam9382 = encode_clo(alloc_clo(lam9382_fptr, 0));

void pierce_u45randomly_fptr(); // pierce-randomly
void pierce_u45randomly_spec(void* _9384, void* kont9198, void* possible_u45holes, void* cave); // pierce-randomly
void* pierce_u45randomly = encode_clo(alloc_clo(pierce_u45randomly_fptr, 0));

void lam9385_fptr(); // lam9385
void lam9385_spec(void* env9386, void* xy8950); // lam9385
void* lam9385 = encode_clo(alloc_clo(lam9385_fptr, 0));

void lam9387_fptr(); // lam9387
void lam9387_spec(void* env9388, void* xy8958); // lam9387
void* lam9387 = encode_clo(alloc_clo(lam9387_fptr, 0));

void lam9389_fptr(); // lam9389
void lam9389_spec(void* env9390, void* id_8960); // lam9389
void* lam9389 = encode_clo(alloc_clo(lam9389_fptr, 0));

void lam9391_fptr(); // lam9391
void lam9391_spec(void* env9392, void* id_8957); // lam9391
void* lam9391 = encode_clo(alloc_clo(lam9391_fptr, 0));

void lam9393_fptr(); // lam9393
void lam9393_spec(void* env9394, void* cont9211, void* i, void* j); // lam9393
void* lam9393 = encode_clo(alloc_clo(lam9393_fptr, 0));

void lam9395_fptr(); // lam9395
void lam9395_spec(void* env9396, void* id_8974); // lam9395
void* lam9395 = encode_clo(alloc_clo(lam9395_fptr, 0));

void lam9397_fptr(); // lam9397
void lam9397_spec(void* env9398, void* id_8972); // lam9397
void* lam9397 = encode_clo(alloc_clo(lam9397_fptr, 0));

void lam9399_fptr(); // lam9399
void lam9399_spec(void* env9400, void* id_8967); // lam9399
void* lam9399 = encode_clo(alloc_clo(lam9399_fptr, 0));

void lam9401_fptr(); // lam9401
void lam9401_spec(void* env9402, void* id_8966); // lam9401
void* lam9401 = encode_clo(alloc_clo(lam9401_fptr, 0));

void lam9403_fptr(); // lam9403
void lam9403_spec(void* env9404, void* cont9205, void* j); // lam9403
void* lam9403 = encode_clo(alloc_clo(lam9403_fptr, 0));

void lam9405_fptr(); // lam9405
void lam9405_spec(void* env9406, void* cont9204, void* i); // lam9405
void* lam9405 = encode_clo(alloc_clo(lam9405_fptr, 0));

void lam9407_fptr(); // lam9407
void lam9407_spec(void* env9408, void* id_8976); // lam9407
void* lam9407 = encode_clo(alloc_clo(lam9407_fptr, 0));

void lam9409_fptr(); // lam9409
void lam9409_spec(void* env9410, void* id_8975); // lam9409
void* lam9409 = encode_clo(alloc_clo(lam9409_fptr, 0));

void lam9411_fptr(); // lam9411
void lam9411_spec(void* env9412, void* possible_u45holes); // lam9411
void* lam9411 = encode_clo(alloc_clo(lam9411_fptr, 0));

void lam9413_fptr(); // lam9413
void lam9413_spec(void* env9414, void* cave); // lam9413
void* lam9413 = encode_clo(alloc_clo(lam9413_fptr, 0));

void lam9415_fptr(); // lam9415
void lam9415_spec(void* env9416, void* id_8955); // lam9415
void* lam9415 = encode_clo(alloc_clo(lam9415_fptr, 0));

void lam9417_fptr(); // lam9417
void lam9417_spec(void* env9418, void* id_8952); // lam9417
void* lam9417 = encode_clo(alloc_clo(lam9417_fptr, 0));

void lam9419_fptr(); // lam9419
void lam9419_spec(void* env9420, void* id_8949); // lam9419
void* lam9419 = encode_clo(alloc_clo(lam9419_fptr, 0));

void make_u45maze_fptr(); // make-maze
void make_u45maze_spec(void* _9421, void* kont9200, void* n, void* m); // make-maze
void* make_u45maze = encode_clo(alloc_clo(make_u45maze_fptr, 0));

void brouhaha_main_fptr(); // brouhaha_main
void brouhaha_main_spec(void* _9422, void* kont9219); // brouhaha_main
void* brouhaha_main = encode_clo(alloc_clo(brouhaha_main_fptr, 0));



inline void _u43_fptr() // + 
{
//decoding closure array
void** decode_clo_array = nullptr;
if(is_cons(arg_buffer[2]))
{
//(apply e0 e0) case
void* const lst = arg_buffer[2];
void* const kont9478 = prim_car(lst);
void* const lst9480 = prim_cdr(lst);
void* const x9479 = apply_prim__u43(lst9480);
arg_buffer[1] = kont9478;
arg_buffer[2] = x9479;
numArgs = 2;
reinterpret_cast<void (*)()>((decode_clo(kont9478))[0])();
}
else
{
void* const kont9478 = arg_buffer[2];
void* const x9479 = apply_prim__u43(arg_buffer);
reinterpret_cast<void (*)(void*, void*)>((decode_clo(kont9478))[0])(kont9478, x9479);
}

}

inline void _u45_fptr() // - 
{
//decoding closure array
void** decode_clo_array = nullptr;
if(is_cons(arg_buffer[2]))
{
//(apply e0 e0) case
void* const lst = arg_buffer[2];
void* const kont9481 = prim_car(lst);
void* const lst9483 = prim_cdr(lst);
void* const x9482 = apply_prim__u45(lst9483);
arg_buffer[1] = kont9481;
arg_buffer[2] = x9482;
numArgs = 2;
reinterpret_cast<void (*)()>((decode_clo(kont9481))[0])();
}
else
{
void* const kont9481 = arg_buffer[2];
void* const x9482 = apply_prim__u45(arg_buffer);
reinterpret_cast<void (*)(void*, void*)>((decode_clo(kont9481))[0])(kont9481, x9482);
}

}

inline void _u42_fptr() // * 
{
//decoding closure array
void** decode_clo_array = nullptr;
if(is_cons(arg_buffer[2]))
{
//(apply e0 e0) case
void* const lst = arg_buffer[2];
void* const kont9484 = prim_car(lst);
void* const lst9486 = prim_cdr(lst);
void* const x9485 = apply_prim__u42(lst9486);
arg_buffer[1] = kont9484;
arg_buffer[2] = x9485;
numArgs = 2;
reinterpret_cast<void (*)()>((decode_clo(kont9484))[0])();
}
else
{
void* const kont9484 = arg_buffer[2];
void* const x9485 = apply_prim__u42(arg_buffer);
reinterpret_cast<void (*)(void*, void*)>((decode_clo(kont9484))[0])(kont9484, x9485);
}

}

inline void _u47_fptr() // / 
{
//decoding closure array
void** decode_clo_array = nullptr;
if(is_cons(arg_buffer[2]))
{
//(apply e0 e0) case
void* const lst = arg_buffer[2];
void* const kont9487 = prim_car(lst);
void* const lst9489 = prim_cdr(lst);
void* const x9488 = apply_prim__u47(lst9489);
arg_buffer[1] = kont9487;
arg_buffer[2] = x9488;
numArgs = 2;
reinterpret_cast<void (*)()>((decode_clo(kont9487))[0])();
}
else
{
void* const kont9487 = arg_buffer[2];
void* const x9488 = apply_prim__u47(arg_buffer);
reinterpret_cast<void (*)(void*, void*)>((decode_clo(kont9487))[0])(kont9487, x9488);
}

}

inline void _u61_fptr() // = 
{
//decoding closure array
void** decode_clo_array = nullptr;
if(is_cons(arg_buffer[2]))
{
//(apply e0 e0) case
void* const lst = arg_buffer[2];
void* const kont9490 = prim_car(lst);
void* const lst9492 = prim_cdr(lst);
void* const x9491 = apply_prim__u61(lst9492);
arg_buffer[1] = kont9490;
arg_buffer[2] = x9491;
numArgs = 2;
reinterpret_cast<void (*)()>((decode_clo(kont9490))[0])();
}
else
{
void* const kont9490 = arg_buffer[2];
void* const x9491 = apply_prim__u61(arg_buffer);
reinterpret_cast<void (*)(void*, void*)>((decode_clo(kont9490))[0])(kont9490, x9491);
}

}

inline void _u62_fptr() // > 
{
//decoding closure array
void** decode_clo_array = nullptr;
if(is_cons(arg_buffer[2]))
{
//(apply e0 e0) case
void* const lst = arg_buffer[2];
void* const kont9493 = prim_car(lst);
void* const lst9495 = prim_cdr(lst);
void* const x9494 = apply_prim__u62(lst9495);
arg_buffer[1] = kont9493;
arg_buffer[2] = x9494;
numArgs = 2;
reinterpret_cast<void (*)()>((decode_clo(kont9493))[0])();
}
else
{
void* const kont9493 = arg_buffer[2];
void* const x9494 = apply_prim__u62(arg_buffer);
reinterpret_cast<void (*)(void*, void*)>((decode_clo(kont9493))[0])(kont9493, x9494);
}

}

inline void _u60_fptr() // < 
{
//decoding closure array
void** decode_clo_array = nullptr;
if(is_cons(arg_buffer[2]))
{
//(apply e0 e0) case
void* const lst = arg_buffer[2];
void* const kont9496 = prim_car(lst);
void* const lst9498 = prim_cdr(lst);
void* const x9497 = apply_prim__u60(lst9498);
arg_buffer[1] = kont9496;
arg_buffer[2] = x9497;
numArgs = 2;
reinterpret_cast<void (*)()>((decode_clo(kont9496))[0])();
}
else
{
void* const kont9496 = arg_buffer[2];
void* const x9497 = apply_prim__u60(arg_buffer);
reinterpret_cast<void (*)(void*, void*)>((decode_clo(kont9496))[0])(kont9496, x9497);
}

}

inline void _u60_u61_fptr() // <= 
{
//decoding closure array
void** decode_clo_array = nullptr;
if(is_cons(arg_buffer[2]))
{
//(apply e0 e0) case
void* const lst = arg_buffer[2];
void* const kont9499 = prim_car(lst);
void* const lst9501 = prim_cdr(lst);
void* const x9500 = apply_prim__u60_u61(lst9501);
arg_buffer[1] = kont9499;
arg_buffer[2] = x9500;
numArgs = 2;
reinterpret_cast<void (*)()>((decode_clo(kont9499))[0])();
}
else
{
void* const kont9499 = arg_buffer[2];
void* const x9500 = apply_prim__u60_u61(arg_buffer);
reinterpret_cast<void (*)(void*, void*)>((decode_clo(kont9499))[0])(kont9499, x9500);
}

}

inline void _u62_u61_fptr() // >= 
{
//decoding closure array
void** decode_clo_array = nullptr;
if(is_cons(arg_buffer[2]))
{
//(apply e0 e0) case
void* const lst = arg_buffer[2];
void* const kont9502 = prim_car(lst);
void* const lst9504 = prim_cdr(lst);
void* const x9503 = apply_prim__u62_u61(lst9504);
arg_buffer[1] = kont9502;
arg_buffer[2] = x9503;
numArgs = 2;
reinterpret_cast<void (*)()>((decode_clo(kont9502))[0])();
}
else
{
void* const kont9502 = arg_buffer[2];
void* const x9503 = apply_prim__u62_u61(arg_buffer);
reinterpret_cast<void (*)(void*, void*)>((decode_clo(kont9502))[0])(kont9502, x9503);
}

}

inline void modulo_fptr() // modulo 
{
//decoding closure array
void** decode_clo_array = nullptr;
if(is_cons(arg_buffer[2]))
{
//(apply e0 e0) case
void* const lst = arg_buffer[2];
void* const kont9505 = prim_car(lst);
void* const lst9507 = prim_cdr(lst);
void* const x9506 = apply_prim_modulo(lst9507);
arg_buffer[1] = kont9505;
arg_buffer[2] = x9506;
numArgs = 2;
reinterpret_cast<void (*)()>((decode_clo(kont9505))[0])();
}
else
{
void* const kont9505 = arg_buffer[2];
void* const x9506 = apply_prim_modulo(arg_buffer);
reinterpret_cast<void (*)(void*, void*)>((decode_clo(kont9505))[0])(kont9505, x9506);
}

}

inline void null_u63_fptr() // null? 
{
//decoding closure array
void** decode_clo_array = nullptr;
if(is_cons(arg_buffer[2]))
{
//(apply e0 e0) case
void* const lst = arg_buffer[2];
void* const kont9508 = prim_car(lst);
void* const lst9510 = prim_cdr(lst);
void* const x9509 = apply_prim_null_u63(lst9510);
arg_buffer[1] = kont9508;
arg_buffer[2] = x9509;
numArgs = 2;
reinterpret_cast<void (*)()>((decode_clo(kont9508))[0])();
}
else
{
void* const kont9508 = arg_buffer[2];
void* const x9509 = apply_prim_null_u63(arg_buffer);
reinterpret_cast<void (*)(void*, void*)>((decode_clo(kont9508))[0])(kont9508, x9509);
}

}

inline void equal_u63_fptr() // equal? 
{
//decoding closure array
void** decode_clo_array = nullptr;
if(is_cons(arg_buffer[2]))
{
//(apply e0 e0) case
void* const lst = arg_buffer[2];
void* const kont9511 = prim_car(lst);
void* const lst9513 = prim_cdr(lst);
void* const x9512 = apply_prim_equal_u63(lst9513);
arg_buffer[1] = kont9511;
arg_buffer[2] = x9512;
numArgs = 2;
reinterpret_cast<void (*)()>((decode_clo(kont9511))[0])();
}
else
{
void* const kont9511 = arg_buffer[2];
void* const x9512 = apply_prim_equal_u63(arg_buffer);
reinterpret_cast<void (*)(void*, void*)>((decode_clo(kont9511))[0])(kont9511, x9512);
}

}

inline void eq_u63_fptr() // eq? 
{
//decoding closure array
void** decode_clo_array = nullptr;
if(is_cons(arg_buffer[2]))
{
//(apply e0 e0) case
void* const lst = arg_buffer[2];
void* const kont9514 = prim_car(lst);
void* const lst9516 = prim_cdr(lst);
void* const x9515 = apply_prim_eq_u63(lst9516);
arg_buffer[1] = kont9514;
arg_buffer[2] = x9515;
numArgs = 2;
reinterpret_cast<void (*)()>((decode_clo(kont9514))[0])();
}
else
{
void* const kont9514 = arg_buffer[2];
void* const x9515 = apply_prim_eq_u63(arg_buffer);
reinterpret_cast<void (*)(void*, void*)>((decode_clo(kont9514))[0])(kont9514, x9515);
}

}

inline void cons_fptr() // cons 
{
//decoding closure array
void** decode_clo_array = nullptr;
if(is_cons(arg_buffer[2]))
{
//(apply e0 e0) case
void* const lst = arg_buffer[2];
void* const kont9517 = prim_car(lst);
void* const lst9519 = prim_cdr(lst);
void* const x9518 = apply_prim_cons(lst9519);
arg_buffer[1] = kont9517;
arg_buffer[2] = x9518;
numArgs = 2;
reinterpret_cast<void (*)()>((decode_clo(kont9517))[0])();
}
else
{
void* const kont9517 = arg_buffer[2];
void* const x9518 = apply_prim_cons(arg_buffer);
reinterpret_cast<void (*)(void*, void*)>((decode_clo(kont9517))[0])(kont9517, x9518);
}

}

inline void car_fptr() // car 
{
//decoding closure array
void** decode_clo_array = nullptr;
if(is_cons(arg_buffer[2]))
{
//(apply e0 e0) case
void* const lst = arg_buffer[2];
void* const kont9520 = prim_car(lst);
void* const lst9522 = prim_cdr(lst);
void* const x9521 = apply_prim_car(lst9522);
arg_buffer[1] = kont9520;
arg_buffer[2] = x9521;
numArgs = 2;
reinterpret_cast<void (*)()>((decode_clo(kont9520))[0])();
}
else
{
void* const kont9520 = arg_buffer[2];
void* const x9521 = apply_prim_car(arg_buffer);
reinterpret_cast<void (*)(void*, void*)>((decode_clo(kont9520))[0])(kont9520, x9521);
}

}

inline void cdr_fptr() // cdr 
{
//decoding closure array
void** decode_clo_array = nullptr;
if(is_cons(arg_buffer[2]))
{
//(apply e0 e0) case
void* const lst = arg_buffer[2];
void* const kont9523 = prim_car(lst);
void* const lst9525 = prim_cdr(lst);
void* const x9524 = apply_prim_cdr(lst9525);
arg_buffer[1] = kont9523;
arg_buffer[2] = x9524;
numArgs = 2;
reinterpret_cast<void (*)()>((decode_clo(kont9523))[0])();
}
else
{
void* const kont9523 = arg_buffer[2];
void* const x9524 = apply_prim_cdr(arg_buffer);
reinterpret_cast<void (*)(void*, void*)>((decode_clo(kont9523))[0])(kont9523, x9524);
}

}

inline void float_u45_u62int_fptr() // float->int 
{
//decoding closure array
void** decode_clo_array = nullptr;
if(is_cons(arg_buffer[2]))
{
//(apply e0 e0) case
void* const lst = arg_buffer[2];
void* const kont9526 = prim_car(lst);
void* const lst9528 = prim_cdr(lst);
void* const x9527 = apply_prim_float_u45_u62int(lst9528);
arg_buffer[1] = kont9526;
arg_buffer[2] = x9527;
numArgs = 2;
reinterpret_cast<void (*)()>((decode_clo(kont9526))[0])();
}
else
{
void* const kont9526 = arg_buffer[2];
void* const x9527 = apply_prim_float_u45_u62int(arg_buffer);
reinterpret_cast<void (*)(void*, void*)>((decode_clo(kont9526))[0])(kont9526, x9527);
}

}

inline void int_u45_u62float_fptr() // int->float 
{
//decoding closure array
void** decode_clo_array = nullptr;
if(is_cons(arg_buffer[2]))
{
//(apply e0 e0) case
void* const lst = arg_buffer[2];
void* const kont9529 = prim_car(lst);
void* const lst9531 = prim_cdr(lst);
void* const x9530 = apply_prim_int_u45_u62float(lst9531);
arg_buffer[1] = kont9529;
arg_buffer[2] = x9530;
numArgs = 2;
reinterpret_cast<void (*)()>((decode_clo(kont9529))[0])();
}
else
{
void* const kont9529 = arg_buffer[2];
void* const x9530 = apply_prim_int_u45_u62float(arg_buffer);
reinterpret_cast<void (*)(void*, void*)>((decode_clo(kont9529))[0])(kont9529, x9530);
}

}

inline void hash_fptr() // hash 
{
//decoding closure array
void** decode_clo_array = nullptr;
if(is_cons(arg_buffer[2]))
{
//(apply e0 e0) case
void* const lst = arg_buffer[2];
void* const kont9532 = prim_car(lst);
void* const lst9534 = prim_cdr(lst);
void* const x9533 = apply_prim_hash(lst9534);
arg_buffer[1] = kont9532;
arg_buffer[2] = x9533;
numArgs = 2;
reinterpret_cast<void (*)()>((decode_clo(kont9532))[0])();
}
else
{
void* const kont9532 = arg_buffer[2];
void* const x9533 = apply_prim_hash(arg_buffer);
reinterpret_cast<void (*)(void*, void*)>((decode_clo(kont9532))[0])(kont9532, x9533);
}

}

inline void hash_u45ref_fptr() // hash-ref 
{
//decoding closure array
void** decode_clo_array = nullptr;
if(is_cons(arg_buffer[2]))
{
//(apply e0 e0) case
void* const lst = arg_buffer[2];
void* const kont9535 = prim_car(lst);
void* const lst9537 = prim_cdr(lst);
void* const x9536 = apply_prim_hash_u45ref(lst9537);
arg_buffer[1] = kont9535;
arg_buffer[2] = x9536;
numArgs = 2;
reinterpret_cast<void (*)()>((decode_clo(kont9535))[0])();
}
else
{
void* const kont9535 = arg_buffer[2];
void* const x9536 = apply_prim_hash_u45ref(arg_buffer);
reinterpret_cast<void (*)(void*, void*)>((decode_clo(kont9535))[0])(kont9535, x9536);
}

}

inline void hash_u45set_fptr() // hash-set 
{
//decoding closure array
void** decode_clo_array = nullptr;
if(is_cons(arg_buffer[2]))
{
//(apply e0 e0) case
void* const lst = arg_buffer[2];
void* const kont9538 = prim_car(lst);
void* const lst9540 = prim_cdr(lst);
void* const x9539 = apply_prim_hash_u45set(lst9540);
arg_buffer[1] = kont9538;
arg_buffer[2] = x9539;
numArgs = 2;
reinterpret_cast<void (*)()>((decode_clo(kont9538))[0])();
}
else
{
void* const kont9538 = arg_buffer[2];
void* const x9539 = apply_prim_hash_u45set(arg_buffer);
reinterpret_cast<void (*)(void*, void*)>((decode_clo(kont9538))[0])(kont9538, x9539);
}

}

inline void hash_u45keys_fptr() // hash-keys 
{
//decoding closure array
void** decode_clo_array = nullptr;
if(is_cons(arg_buffer[2]))
{
//(apply e0 e0) case
void* const lst = arg_buffer[2];
void* const kont9541 = prim_car(lst);
void* const lst9543 = prim_cdr(lst);
void* const x9542 = apply_prim_hash_u45keys(lst9543);
arg_buffer[1] = kont9541;
arg_buffer[2] = x9542;
numArgs = 2;
reinterpret_cast<void (*)()>((decode_clo(kont9541))[0])();
}
else
{
void* const kont9541 = arg_buffer[2];
void* const x9542 = apply_prim_hash_u45keys(arg_buffer);
reinterpret_cast<void (*)(void*, void*)>((decode_clo(kont9541))[0])(kont9541, x9542);
}

}

inline void hash_u45has_u45key_u63_fptr() // hash-has-key? 
{
//decoding closure array
void** decode_clo_array = nullptr;
if(is_cons(arg_buffer[2]))
{
//(apply e0 e0) case
void* const lst = arg_buffer[2];
void* const kont9544 = prim_car(lst);
void* const lst9546 = prim_cdr(lst);
void* const x9545 = apply_prim_hash_u45has_u45key_u63(lst9546);
arg_buffer[1] = kont9544;
arg_buffer[2] = x9545;
numArgs = 2;
reinterpret_cast<void (*)()>((decode_clo(kont9544))[0])();
}
else
{
void* const kont9544 = arg_buffer[2];
void* const x9545 = apply_prim_hash_u45has_u45key_u63(arg_buffer);
reinterpret_cast<void (*)(void*, void*)>((decode_clo(kont9544))[0])(kont9544, x9545);
}

}

inline void hash_u45count_fptr() // hash-count 
{
//decoding closure array
void** decode_clo_array = nullptr;
if(is_cons(arg_buffer[2]))
{
//(apply e0 e0) case
void* const lst = arg_buffer[2];
void* const kont9547 = prim_car(lst);
void* const lst9549 = prim_cdr(lst);
void* const x9548 = apply_prim_hash_u45count(lst9549);
arg_buffer[1] = kont9547;
arg_buffer[2] = x9548;
numArgs = 2;
reinterpret_cast<void (*)()>((decode_clo(kont9547))[0])();
}
else
{
void* const kont9547 = arg_buffer[2];
void* const x9548 = apply_prim_hash_u45count(arg_buffer);
reinterpret_cast<void (*)(void*, void*)>((decode_clo(kont9547))[0])(kont9547, x9548);
}

}

inline void set_fptr() // set 
{
//decoding closure array
void** decode_clo_array = nullptr;
if(is_cons(arg_buffer[2]))
{
//(apply e0 e0) case
void* const lst = arg_buffer[2];
void* const kont9550 = prim_car(lst);
void* const lst9552 = prim_cdr(lst);
void* const x9551 = apply_prim_set(lst9552);
arg_buffer[1] = kont9550;
arg_buffer[2] = x9551;
numArgs = 2;
reinterpret_cast<void (*)()>((decode_clo(kont9550))[0])();
}
else
{
void* const kont9550 = arg_buffer[2];
void* const x9551 = apply_prim_set(arg_buffer);
reinterpret_cast<void (*)(void*, void*)>((decode_clo(kont9550))[0])(kont9550, x9551);
}

}

inline void set_u45_u62list_fptr() // set->list 
{
//decoding closure array
void** decode_clo_array = nullptr;
if(is_cons(arg_buffer[2]))
{
//(apply e0 e0) case
void* const lst = arg_buffer[2];
void* const kont9553 = prim_car(lst);
void* const lst9555 = prim_cdr(lst);
void* const x9554 = apply_prim_set_u45_u62list(lst9555);
arg_buffer[1] = kont9553;
arg_buffer[2] = x9554;
numArgs = 2;
reinterpret_cast<void (*)()>((decode_clo(kont9553))[0])();
}
else
{
void* const kont9553 = arg_buffer[2];
void* const x9554 = apply_prim_set_u45_u62list(arg_buffer);
reinterpret_cast<void (*)(void*, void*)>((decode_clo(kont9553))[0])(kont9553, x9554);
}

}

inline void list_u45_u62set_fptr() // list->set 
{
//decoding closure array
void** decode_clo_array = nullptr;
if(is_cons(arg_buffer[2]))
{
//(apply e0 e0) case
void* const lst = arg_buffer[2];
void* const kont9556 = prim_car(lst);
void* const lst9558 = prim_cdr(lst);
void* const x9557 = apply_prim_list_u45_u62set(lst9558);
arg_buffer[1] = kont9556;
arg_buffer[2] = x9557;
numArgs = 2;
reinterpret_cast<void (*)()>((decode_clo(kont9556))[0])();
}
else
{
void* const kont9556 = arg_buffer[2];
void* const x9557 = apply_prim_list_u45_u62set(arg_buffer);
reinterpret_cast<void (*)(void*, void*)>((decode_clo(kont9556))[0])(kont9556, x9557);
}

}

inline void set_u45add_fptr() // set-add 
{
//decoding closure array
void** decode_clo_array = nullptr;
if(is_cons(arg_buffer[2]))
{
//(apply e0 e0) case
void* const lst = arg_buffer[2];
void* const kont9559 = prim_car(lst);
void* const lst9561 = prim_cdr(lst);
void* const x9560 = apply_prim_set_u45add(lst9561);
arg_buffer[1] = kont9559;
arg_buffer[2] = x9560;
numArgs = 2;
reinterpret_cast<void (*)()>((decode_clo(kont9559))[0])();
}
else
{
void* const kont9559 = arg_buffer[2];
void* const x9560 = apply_prim_set_u45add(arg_buffer);
reinterpret_cast<void (*)(void*, void*)>((decode_clo(kont9559))[0])(kont9559, x9560);
}

}

inline void set_u45member_u63_fptr() // set-member? 
{
//decoding closure array
void** decode_clo_array = nullptr;
if(is_cons(arg_buffer[2]))
{
//(apply e0 e0) case
void* const lst = arg_buffer[2];
void* const kont9562 = prim_car(lst);
void* const lst9564 = prim_cdr(lst);
void* const x9563 = apply_prim_set_u45member_u63(lst9564);
arg_buffer[1] = kont9562;
arg_buffer[2] = x9563;
numArgs = 2;
reinterpret_cast<void (*)()>((decode_clo(kont9562))[0])();
}
else
{
void* const kont9562 = arg_buffer[2];
void* const x9563 = apply_prim_set_u45member_u63(arg_buffer);
reinterpret_cast<void (*)(void*, void*)>((decode_clo(kont9562))[0])(kont9562, x9563);
}

}

inline void set_u45remove_fptr() // set-remove 
{
//decoding closure array
void** decode_clo_array = nullptr;
if(is_cons(arg_buffer[2]))
{
//(apply e0 e0) case
void* const lst = arg_buffer[2];
void* const kont9565 = prim_car(lst);
void* const lst9567 = prim_cdr(lst);
void* const x9566 = apply_prim_set_u45remove(lst9567);
arg_buffer[1] = kont9565;
arg_buffer[2] = x9566;
numArgs = 2;
reinterpret_cast<void (*)()>((decode_clo(kont9565))[0])();
}
else
{
void* const kont9565 = arg_buffer[2];
void* const x9566 = apply_prim_set_u45remove(arg_buffer);
reinterpret_cast<void (*)(void*, void*)>((decode_clo(kont9565))[0])(kont9565, x9566);
}

}

inline void set_u45count_fptr() // set-count 
{
//decoding closure array
void** decode_clo_array = nullptr;
if(is_cons(arg_buffer[2]))
{
//(apply e0 e0) case
void* const lst = arg_buffer[2];
void* const kont9568 = prim_car(lst);
void* const lst9570 = prim_cdr(lst);
void* const x9569 = apply_prim_set_u45count(lst9570);
arg_buffer[1] = kont9568;
arg_buffer[2] = x9569;
numArgs = 2;
reinterpret_cast<void (*)()>((decode_clo(kont9568))[0])();
}
else
{
void* const kont9568 = arg_buffer[2];
void* const x9569 = apply_prim_set_u45count(arg_buffer);
reinterpret_cast<void (*)(void*, void*)>((decode_clo(kont9568))[0])(kont9568, x9569);
}

}

inline void string_u63_fptr() // string? 
{
//decoding closure array
void** decode_clo_array = nullptr;
if(is_cons(arg_buffer[2]))
{
//(apply e0 e0) case
void* const lst = arg_buffer[2];
void* const kont9571 = prim_car(lst);
void* const lst9573 = prim_cdr(lst);
void* const x9572 = apply_prim_string_u63(lst9573);
arg_buffer[1] = kont9571;
arg_buffer[2] = x9572;
numArgs = 2;
reinterpret_cast<void (*)()>((decode_clo(kont9571))[0])();
}
else
{
void* const kont9571 = arg_buffer[2];
void* const x9572 = apply_prim_string_u63(arg_buffer);
reinterpret_cast<void (*)(void*, void*)>((decode_clo(kont9571))[0])(kont9571, x9572);
}

}

inline void string_u45length_fptr() // string-length 
{
//decoding closure array
void** decode_clo_array = nullptr;
if(is_cons(arg_buffer[2]))
{
//(apply e0 e0) case
void* const lst = arg_buffer[2];
void* const kont9574 = prim_car(lst);
void* const lst9576 = prim_cdr(lst);
void* const x9575 = apply_prim_string_u45length(lst9576);
arg_buffer[1] = kont9574;
arg_buffer[2] = x9575;
numArgs = 2;
reinterpret_cast<void (*)()>((decode_clo(kont9574))[0])();
}
else
{
void* const kont9574 = arg_buffer[2];
void* const x9575 = apply_prim_string_u45length(arg_buffer);
reinterpret_cast<void (*)(void*, void*)>((decode_clo(kont9574))[0])(kont9574, x9575);
}

}

inline void string_u45ref_fptr() // string-ref 
{
//decoding closure array
void** decode_clo_array = nullptr;
if(is_cons(arg_buffer[2]))
{
//(apply e0 e0) case
void* const lst = arg_buffer[2];
void* const kont9577 = prim_car(lst);
void* const lst9579 = prim_cdr(lst);
void* const x9578 = apply_prim_string_u45ref(lst9579);
arg_buffer[1] = kont9577;
arg_buffer[2] = x9578;
numArgs = 2;
reinterpret_cast<void (*)()>((decode_clo(kont9577))[0])();
}
else
{
void* const kont9577 = arg_buffer[2];
void* const x9578 = apply_prim_string_u45ref(arg_buffer);
reinterpret_cast<void (*)(void*, void*)>((decode_clo(kont9577))[0])(kont9577, x9578);
}

}

inline void substring_fptr() // substring 
{
//decoding closure array
void** decode_clo_array = nullptr;
if(is_cons(arg_buffer[2]))
{
//(apply e0 e0) case
void* const lst = arg_buffer[2];
void* const kont9580 = prim_car(lst);
void* const lst9582 = prim_cdr(lst);
void* const x9581 = apply_prim_substring(lst9582);
arg_buffer[1] = kont9580;
arg_buffer[2] = x9581;
numArgs = 2;
reinterpret_cast<void (*)()>((decode_clo(kont9580))[0])();
}
else
{
void* const kont9580 = arg_buffer[2];
void* const x9581 = apply_prim_substring(arg_buffer);
reinterpret_cast<void (*)(void*, void*)>((decode_clo(kont9580))[0])(kont9580, x9581);
}

}

inline void string_u45append_fptr() // string-append 
{
//decoding closure array
void** decode_clo_array = nullptr;
if(is_cons(arg_buffer[2]))
{
//(apply e0 e0) case
void* const lst = arg_buffer[2];
void* const kont9583 = prim_car(lst);
void* const lst9585 = prim_cdr(lst);
void* const x9584 = apply_prim_string_u45append(lst9585);
arg_buffer[1] = kont9583;
arg_buffer[2] = x9584;
numArgs = 2;
reinterpret_cast<void (*)()>((decode_clo(kont9583))[0])();
}
else
{
void* const kont9583 = arg_buffer[2];
void* const x9584 = apply_prim_string_u45append(arg_buffer);
reinterpret_cast<void (*)(void*, void*)>((decode_clo(kont9583))[0])(kont9583, x9584);
}

}

inline void string_u45_u62list_fptr() // string->list 
{
//decoding closure array
void** decode_clo_array = nullptr;
if(is_cons(arg_buffer[2]))
{
//(apply e0 e0) case
void* const lst = arg_buffer[2];
void* const kont9586 = prim_car(lst);
void* const lst9588 = prim_cdr(lst);
void* const x9587 = apply_prim_string_u45_u62list(lst9588);
arg_buffer[1] = kont9586;
arg_buffer[2] = x9587;
numArgs = 2;
reinterpret_cast<void (*)()>((decode_clo(kont9586))[0])();
}
else
{
void* const kont9586 = arg_buffer[2];
void* const x9587 = apply_prim_string_u45_u62list(arg_buffer);
reinterpret_cast<void (*)(void*, void*)>((decode_clo(kont9586))[0])(kont9586, x9587);
}

}

inline void exact_u45floor_fptr() // exact-floor 
{
//decoding closure array
void** decode_clo_array = nullptr;
if(is_cons(arg_buffer[2]))
{
//(apply e0 e0) case
void* const lst = arg_buffer[2];
void* const kont9589 = prim_car(lst);
void* const lst9591 = prim_cdr(lst);
void* const x9590 = apply_prim_exact_u45floor(lst9591);
arg_buffer[1] = kont9589;
arg_buffer[2] = x9590;
numArgs = 2;
reinterpret_cast<void (*)()>((decode_clo(kont9589))[0])();
}
else
{
void* const kont9589 = arg_buffer[2];
void* const x9590 = apply_prim_exact_u45floor(arg_buffer);
reinterpret_cast<void (*)(void*, void*)>((decode_clo(kont9589))[0])(kont9589, x9590);
}

}

inline void exact_u45ceiling_fptr() // exact-ceiling 
{
//decoding closure array
void** decode_clo_array = nullptr;
if(is_cons(arg_buffer[2]))
{
//(apply e0 e0) case
void* const lst = arg_buffer[2];
void* const kont9592 = prim_car(lst);
void* const lst9594 = prim_cdr(lst);
void* const x9593 = apply_prim_exact_u45ceiling(lst9594);
arg_buffer[1] = kont9592;
arg_buffer[2] = x9593;
numArgs = 2;
reinterpret_cast<void (*)()>((decode_clo(kont9592))[0])();
}
else
{
void* const kont9592 = arg_buffer[2];
void* const x9593 = apply_prim_exact_u45ceiling(arg_buffer);
reinterpret_cast<void (*)(void*, void*)>((decode_clo(kont9592))[0])(kont9592, x9593);
}

}

inline void exact_u45round_fptr() // exact-round 
{
//decoding closure array
void** decode_clo_array = nullptr;
if(is_cons(arg_buffer[2]))
{
//(apply e0 e0) case
void* const lst = arg_buffer[2];
void* const kont9595 = prim_car(lst);
void* const lst9597 = prim_cdr(lst);
void* const x9596 = apply_prim_exact_u45round(lst9597);
arg_buffer[1] = kont9595;
arg_buffer[2] = x9596;
numArgs = 2;
reinterpret_cast<void (*)()>((decode_clo(kont9595))[0])();
}
else
{
void* const kont9595 = arg_buffer[2];
void* const x9596 = apply_prim_exact_u45round(arg_buffer);
reinterpret_cast<void (*)(void*, void*)>((decode_clo(kont9595))[0])(kont9595, x9596);
}

}

inline void abs_fptr() // abs 
{
//decoding closure array
void** decode_clo_array = nullptr;
if(is_cons(arg_buffer[2]))
{
//(apply e0 e0) case
void* const lst = arg_buffer[2];
void* const kont9598 = prim_car(lst);
void* const lst9600 = prim_cdr(lst);
void* const x9599 = apply_prim_abs(lst9600);
arg_buffer[1] = kont9598;
arg_buffer[2] = x9599;
numArgs = 2;
reinterpret_cast<void (*)()>((decode_clo(kont9598))[0])();
}
else
{
void* const kont9598 = arg_buffer[2];
void* const x9599 = apply_prim_abs(arg_buffer);
reinterpret_cast<void (*)(void*, void*)>((decode_clo(kont9598))[0])(kont9598, x9599);
}

}

inline void max_fptr() // max 
{
//decoding closure array
void** decode_clo_array = nullptr;
if(is_cons(arg_buffer[2]))
{
//(apply e0 e0) case
void* const lst = arg_buffer[2];
void* const kont9601 = prim_car(lst);
void* const lst9603 = prim_cdr(lst);
void* const x9602 = apply_prim_max(lst9603);
arg_buffer[1] = kont9601;
arg_buffer[2] = x9602;
numArgs = 2;
reinterpret_cast<void (*)()>((decode_clo(kont9601))[0])();
}
else
{
void* const kont9601 = arg_buffer[2];
void* const x9602 = apply_prim_max(arg_buffer);
reinterpret_cast<void (*)(void*, void*)>((decode_clo(kont9601))[0])(kont9601, x9602);
}

}

inline void min_fptr() // min 
{
//decoding closure array
void** decode_clo_array = nullptr;
if(is_cons(arg_buffer[2]))
{
//(apply e0 e0) case
void* const lst = arg_buffer[2];
void* const kont9604 = prim_car(lst);
void* const lst9606 = prim_cdr(lst);
void* const x9605 = apply_prim_min(lst9606);
arg_buffer[1] = kont9604;
arg_buffer[2] = x9605;
numArgs = 2;
reinterpret_cast<void (*)()>((decode_clo(kont9604))[0])();
}
else
{
void* const kont9604 = arg_buffer[2];
void* const x9605 = apply_prim_min(arg_buffer);
reinterpret_cast<void (*)(void*, void*)>((decode_clo(kont9604))[0])(kont9604, x9605);
}

}

inline void expt_fptr() // expt 
{
//decoding closure array
void** decode_clo_array = nullptr;
if(is_cons(arg_buffer[2]))
{
//(apply e0 e0) case
void* const lst = arg_buffer[2];
void* const kont9607 = prim_car(lst);
void* const lst9609 = prim_cdr(lst);
void* const x9608 = apply_prim_expt(lst9609);
arg_buffer[1] = kont9607;
arg_buffer[2] = x9608;
numArgs = 2;
reinterpret_cast<void (*)()>((decode_clo(kont9607))[0])();
}
else
{
void* const kont9607 = arg_buffer[2];
void* const x9608 = apply_prim_expt(arg_buffer);
reinterpret_cast<void (*)(void*, void*)>((decode_clo(kont9607))[0])(kont9607, x9608);
}

}

inline void sqrt_fptr() // sqrt 
{
//decoding closure array
void** decode_clo_array = nullptr;
if(is_cons(arg_buffer[2]))
{
//(apply e0 e0) case
void* const lst = arg_buffer[2];
void* const kont9610 = prim_car(lst);
void* const lst9612 = prim_cdr(lst);
void* const x9611 = apply_prim_sqrt(lst9612);
arg_buffer[1] = kont9610;
arg_buffer[2] = x9611;
numArgs = 2;
reinterpret_cast<void (*)()>((decode_clo(kont9610))[0])();
}
else
{
void* const kont9610 = arg_buffer[2];
void* const x9611 = apply_prim_sqrt(arg_buffer);
reinterpret_cast<void (*)(void*, void*)>((decode_clo(kont9610))[0])(kont9610, x9611);
}

}

inline void remainder_fptr() // remainder 
{
//decoding closure array
void** decode_clo_array = nullptr;
if(is_cons(arg_buffer[2]))
{
//(apply e0 e0) case
void* const lst = arg_buffer[2];
void* const kont9613 = prim_car(lst);
void* const lst9615 = prim_cdr(lst);
void* const x9614 = apply_prim_remainder(lst9615);
arg_buffer[1] = kont9613;
arg_buffer[2] = x9614;
numArgs = 2;
reinterpret_cast<void (*)()>((decode_clo(kont9613))[0])();
}
else
{
void* const kont9613 = arg_buffer[2];
void* const x9614 = apply_prim_remainder(arg_buffer);
reinterpret_cast<void (*)(void*, void*)>((decode_clo(kont9613))[0])(kont9613, x9614);
}

}

inline void quotient_fptr() // quotient 
{
//decoding closure array
void** decode_clo_array = nullptr;
if(is_cons(arg_buffer[2]))
{
//(apply e0 e0) case
void* const lst = arg_buffer[2];
void* const kont9616 = prim_car(lst);
void* const lst9618 = prim_cdr(lst);
void* const x9617 = apply_prim_quotient(lst9618);
arg_buffer[1] = kont9616;
arg_buffer[2] = x9617;
numArgs = 2;
reinterpret_cast<void (*)()>((decode_clo(kont9616))[0])();
}
else
{
void* const kont9616 = arg_buffer[2];
void* const x9617 = apply_prim_quotient(arg_buffer);
reinterpret_cast<void (*)(void*, void*)>((decode_clo(kont9616))[0])(kont9616, x9617);
}

}

inline void random_fptr() // random 
{
//decoding closure array
void** decode_clo_array = nullptr;
if(is_cons(arg_buffer[2]))
{
//(apply e0 e0) case
void* const lst = arg_buffer[2];
void* const kont9619 = prim_car(lst);
void* const lst9621 = prim_cdr(lst);
void* const x9620 = apply_prim_random(lst9621);
arg_buffer[1] = kont9619;
arg_buffer[2] = x9620;
numArgs = 2;
reinterpret_cast<void (*)()>((decode_clo(kont9619))[0])();
}
else
{
void* const kont9619 = arg_buffer[2];
void* const x9620 = apply_prim_random(arg_buffer);
reinterpret_cast<void (*)(void*, void*)>((decode_clo(kont9619))[0])(kont9619, x9620);
}

}

inline void symbol_u63_fptr() // symbol? 
{
//decoding closure array
void** decode_clo_array = nullptr;
if(is_cons(arg_buffer[2]))
{
//(apply e0 e0) case
void* const lst = arg_buffer[2];
void* const kont9622 = prim_car(lst);
void* const lst9624 = prim_cdr(lst);
void* const x9623 = apply_prim_symbol_u63(lst9624);
arg_buffer[1] = kont9622;
arg_buffer[2] = x9623;
numArgs = 2;
reinterpret_cast<void (*)()>((decode_clo(kont9622))[0])();
}
else
{
void* const kont9622 = arg_buffer[2];
void* const x9623 = apply_prim_symbol_u63(arg_buffer);
reinterpret_cast<void (*)(void*, void*)>((decode_clo(kont9622))[0])(kont9622, x9623);
}

}

inline void pair_u63_fptr() // pair? 
{
//decoding closure array
void** decode_clo_array = nullptr;
if(is_cons(arg_buffer[2]))
{
//(apply e0 e0) case
void* const lst = arg_buffer[2];
void* const kont9625 = prim_car(lst);
void* const lst9627 = prim_cdr(lst);
void* const x9626 = apply_prim_pair_u63(lst9627);
arg_buffer[1] = kont9625;
arg_buffer[2] = x9626;
numArgs = 2;
reinterpret_cast<void (*)()>((decode_clo(kont9625))[0])();
}
else
{
void* const kont9625 = arg_buffer[2];
void* const x9626 = apply_prim_pair_u63(arg_buffer);
reinterpret_cast<void (*)(void*, void*)>((decode_clo(kont9625))[0])(kont9625, x9626);
}

}

inline void positive_u63_fptr() // positive? 
{
//decoding closure array
void** decode_clo_array = nullptr;
if(is_cons(arg_buffer[2]))
{
//(apply e0 e0) case
void* const lst = arg_buffer[2];
void* const kont9628 = prim_car(lst);
void* const lst9630 = prim_cdr(lst);
void* const x9629 = apply_prim_positive_u63(lst9630);
arg_buffer[1] = kont9628;
arg_buffer[2] = x9629;
numArgs = 2;
reinterpret_cast<void (*)()>((decode_clo(kont9628))[0])();
}
else
{
void* const kont9628 = arg_buffer[2];
void* const x9629 = apply_prim_positive_u63(arg_buffer);
reinterpret_cast<void (*)(void*, void*)>((decode_clo(kont9628))[0])(kont9628, x9629);
}

}

inline void negative_u63_fptr() // negative? 
{
//decoding closure array
void** decode_clo_array = nullptr;
if(is_cons(arg_buffer[2]))
{
//(apply e0 e0) case
void* const lst = arg_buffer[2];
void* const kont9631 = prim_car(lst);
void* const lst9633 = prim_cdr(lst);
void* const x9632 = apply_prim_negative_u63(lst9633);
arg_buffer[1] = kont9631;
arg_buffer[2] = x9632;
numArgs = 2;
reinterpret_cast<void (*)()>((decode_clo(kont9631))[0])();
}
else
{
void* const kont9631 = arg_buffer[2];
void* const x9632 = apply_prim_negative_u63(arg_buffer);
reinterpret_cast<void (*)(void*, void*)>((decode_clo(kont9631))[0])(kont9631, x9632);
}

}

inline void list_fptr() // list 
{
//decoding closure array
void** decode_clo_array = nullptr;
if(is_cons(arg_buffer[2]))
{
//(apply e0 e0) case
void* const lst = arg_buffer[2];
void* const kont9634 = prim_car(lst);
void* const lst9636 = prim_cdr(lst);
void* const x9635 = apply_prim_list(lst9636);
arg_buffer[1] = kont9634;
arg_buffer[2] = x9635;
numArgs = 2;
reinterpret_cast<void (*)()>((decode_clo(kont9634))[0])();
}
else
{
void* const kont9634 = arg_buffer[2];
void* const x9635 = apply_prim_list(arg_buffer);
reinterpret_cast<void (*)(void*, void*)>((decode_clo(kont9634))[0])(kont9634, x9635);
}

}

inline void even_u63_fptr() // even? -> generic version 
{
//reading env and args
void* const kont9096 = arg_buffer[2];
void* const x = arg_buffer[3];
//decoding closure array
void** decode_clo_array = nullptr;
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(kont9096)[0])(kont9096, apply_prim_equal_u63_2(int9475, apply_prim_modulo_2(x, int9426)));
}

inline void even_u63_spec(void* _9221, void* kont9096, void* x) // even? 
{
//decoding closure array
void** decode_clo_array = nullptr;
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(kont9096)[0])(kont9096, apply_prim_equal_u63_2(int9475, apply_prim_modulo_2(x, int9426)));
}

inline void odd_u63_fptr() // odd? -> generic version 
{
//reading env and args
void* const kont9097 = arg_buffer[2];
void* const x = arg_buffer[3];
//decoding closure array
void** decode_clo_array = nullptr;
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(kont9097)[0])(kont9097, apply_prim_equal_u63_2(int9468, apply_prim_modulo_2(x, int9426)));
}

inline void odd_u63_spec(void* _9222, void* kont9097, void* x) // odd? 
{
//decoding closure array
void** decode_clo_array = nullptr;
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(kont9097)[0])(kont9097, apply_prim_equal_u63_2(int9468, apply_prim_modulo_2(x, int9426)));
}

inline void list_u45ref_fptr() // list-ref -> generic version 
{
//reading env and args
void* const kont9098 = arg_buffer[2];
void* const lst = arg_buffer[3];
void* const n = arg_buffer[4];
//decoding closure array
void** decode_clo_array = nullptr;

//if-clause
if(is_true(apply_prim__u61_2(int9475, n)))
{
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(kont9098)[0])(kont9098, apply_prim_car_1(lst));
}
else
{

//clo-app
list_u45ref_spec(list_u45ref, kont9098, apply_prim_cdr_1(lst), apply_prim__u45_2(n, int9468));
}

}

inline void list_u45ref_spec(void* _9223, void* kont9098, void* lst, void* n) // list-ref 
{
//decoding closure array
void** decode_clo_array = nullptr;

//if-clause
if(is_true(apply_prim__u61_2(int9475, n)))
{
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(kont9098)[0])(kont9098, apply_prim_car_1(lst));
}
else
{

//clo-app
list_u45ref_spec(list_u45ref, kont9098, apply_prim_cdr_1(lst), apply_prim__u45_2(n, int9468));
}

}

inline void lam9224_fptr() // lam9224 -> generic version 
{
//reading env
void* const env9225 = arg_buffer[1];
//reading env and args
void* const id_8745 = arg_buffer[2];
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9225);

//if-clause
if(is_true(id_8745))
{
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(decode_clo_array[1])[0])(decode_clo_array[1], bool_f9473);
}
else
{

//if-clause
if(is_true(apply_prim_equal_u63_2(decode_clo_array[2], apply_prim_car_1(decode_clo_array[3]))))
{
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(decode_clo_array[1])[0])(decode_clo_array[1], decode_clo_array[3]);
}
else
{

//clo-app
member_spec(member, decode_clo_array[1], decode_clo_array[2], apply_prim_cdr_1(decode_clo_array[3]));
}

}

}

inline void lam9224_spec(void* env9225, void* id_8745) // lam9224 
{
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9225);

//if-clause
if(is_true(id_8745))
{
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(decode_clo_array[1])[0])(decode_clo_array[1], bool_f9473);
}
else
{

//if-clause
if(is_true(apply_prim_equal_u63_2(decode_clo_array[2], apply_prim_car_1(decode_clo_array[3]))))
{
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(decode_clo_array[1])[0])(decode_clo_array[1], decode_clo_array[3]);
}
else
{

//clo-app
member_spec(member, decode_clo_array[1], decode_clo_array[2], apply_prim_cdr_1(decode_clo_array[3]));
}

}

}

inline void member_fptr() // member -> generic version 
{
//reading env and args
void* const kont9099 = arg_buffer[2];
void* const item = arg_buffer[3];
void* const lst = arg_buffer[4];
//decoding closure array
void** decode_clo_array = nullptr;

//creating new make-kont closure
void** clo9637 = alloc_kont(lam9224_spec, 3);

//setting env list
clo9637[1] = kont9099;
clo9637[2] = item;
clo9637[3] = lst;
void* f_lam_9100 = encode_clo(clo9637);



//if-clause
if(is_true(apply_prim_null_u63_1(item)))
{
// kont-clo-app case
lam9224_spec(f_lam_9100, apply_prim_null_u63_1(item));
}
else
{
// kont-clo-app case
lam9224_spec(f_lam_9100, apply_prim_null_u63_1(lst));
}

}

inline void member_spec(void* _9226, void* kont9099, void* item, void* lst) // member 
{
//decoding closure array
void** decode_clo_array = nullptr;

//creating new make-kont closure
void** clo9638 = alloc_kont(lam9224_spec, 3);

//setting env list
clo9638[1] = kont9099;
clo9638[2] = item;
clo9638[3] = lst;
void* f_lam_9100 = encode_clo(clo9638);



//if-clause
if(is_true(apply_prim_null_u63_1(item)))
{
// kont-clo-app case
lam9224_spec(f_lam_9100, apply_prim_null_u63_1(item));
}
else
{
// kont-clo-app case
lam9224_spec(f_lam_9100, apply_prim_null_u63_1(lst));
}

}

inline void member_u63_fptr() // member? -> generic version 
{
//reading env and args
void* const kont9101 = arg_buffer[2];
void* const x = arg_buffer[3];
void* const lst = arg_buffer[4];
//decoding closure array
void** decode_clo_array = nullptr;

//if-clause
if(is_true(apply_prim_null_u63_1(lst)))
{
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(kont9101)[0])(kont9101, bool_f9473);
}
else
{

//if-clause
if(is_true(apply_prim_equal_u63_2(apply_prim_car_1(lst), x)))
{
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(kont9101)[0])(kont9101, bool_t9470);
}
else
{

//clo-app
member_u63_spec(member_u63, kont9101, x, apply_prim_cdr_1(lst));
}

}

}

inline void member_u63_spec(void* _9227, void* kont9101, void* x, void* lst) // member? 
{
//decoding closure array
void** decode_clo_array = nullptr;

//if-clause
if(is_true(apply_prim_null_u63_1(lst)))
{
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(kont9101)[0])(kont9101, bool_f9473);
}
else
{

//if-clause
if(is_true(apply_prim_equal_u63_2(apply_prim_car_1(lst), x)))
{
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(kont9101)[0])(kont9101, bool_t9470);
}
else
{

//clo-app
member_u63_spec(member_u63, kont9101, x, apply_prim_cdr_1(lst));
}

}

}

inline void lam9228_fptr() // lam9228 -> generic version 
{
//reading env
void* const env9229 = arg_buffer[1];
//reading env and args
void* const id_8760 = arg_buffer[2];
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9229);
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(decode_clo_array[1])[0])(decode_clo_array[1], apply_prim__u43_2(decode_clo_array[2], id_8760));
}

inline void lam9228_spec(void* env9229, void* id_8760) // lam9228 
{
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9229);
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(decode_clo_array[1])[0])(decode_clo_array[1], apply_prim__u43_2(decode_clo_array[2], id_8760));
}

inline void length_fptr() // length -> generic version 
{
//reading env and args
void* const kont9102 = arg_buffer[2];
void* const lst = arg_buffer[3];
//decoding closure array
void** decode_clo_array = nullptr;

//if-clause
if(is_true(apply_prim_null_u63_1(lst)))
{
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(kont9102)[0])(kont9102, int9475);
}
else
{

//creating new make-kont closure
void** clo9639 = alloc_kont(lam9228_spec, 2);

//setting env list
clo9639[1] = kont9102;
clo9639[2] = int9468;
void* f_lam_9103 = encode_clo(clo9639);



//clo-app
length_spec(length, f_lam_9103, apply_prim_cdr_1(lst));
}

}

inline void length_spec(void* _9230, void* kont9102, void* lst) // length 
{
//decoding closure array
void** decode_clo_array = nullptr;

//if-clause
if(is_true(apply_prim_null_u63_1(lst)))
{
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(kont9102)[0])(kont9102, int9475);
}
else
{

//creating new make-kont closure
void** clo9640 = alloc_kont(lam9228_spec, 2);

//setting env list
clo9640[1] = kont9102;
clo9640[2] = int9468;
void* f_lam_9103 = encode_clo(clo9640);



//clo-app
length_spec(length, f_lam_9103, apply_prim_cdr_1(lst));
}

}

inline void lam9231_fptr() // lam9231 -> generic version 
{
//reading env
void* const env9232 = arg_buffer[1];
//reading env and args
void* const id_8766 = arg_buffer[2];
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9232);
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(decode_clo_array[1])[0])(decode_clo_array[1], apply_prim_cons_2(decode_clo_array[2], id_8766));
}

inline void lam9231_spec(void* env9232, void* id_8766) // lam9231 
{
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9232);
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(decode_clo_array[1])[0])(decode_clo_array[1], apply_prim_cons_2(decode_clo_array[2], id_8766));
}

inline void lam9233_fptr() // lam9233 -> generic version 
{
//reading env
void* const env9234 = arg_buffer[1];
//reading env and args
void* const id_8764 = arg_buffer[2];
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9234);

//creating new make-kont closure
void** clo9641 = alloc_kont(lam9231_spec, 2);

//setting env list
clo9641[1] = decode_clo_array[1];
clo9641[2] = id_8764;
void* f_lam_9105 = encode_clo(clo9641);



//clo-app
map_spec(map, f_lam_9105, decode_clo_array[2], apply_prim_cdr_1(decode_clo_array[3]));
}

inline void lam9233_spec(void* env9234, void* id_8764) // lam9233 
{
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9234);

//creating new make-kont closure
void** clo9642 = alloc_kont(lam9231_spec, 2);

//setting env list
clo9642[1] = decode_clo_array[1];
clo9642[2] = id_8764;
void* f_lam_9105 = encode_clo(clo9642);



//clo-app
map_spec(map, f_lam_9105, decode_clo_array[2], apply_prim_cdr_1(decode_clo_array[3]));
}

inline void map_fptr() // map -> generic version 
{
//reading env and args
void* const kont9104 = arg_buffer[2];
void* const proc = arg_buffer[3];
void* const lst = arg_buffer[4];
//decoding closure array
void** decode_clo_array = nullptr;

//if-clause
if(is_true(apply_prim_null_u63_1(lst)))
{
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(kont9104)[0])(kont9104, apply_prim_list_0());
}
else
{

//creating new make-kont closure
void** clo9643 = alloc_kont(lam9233_spec, 3);

//setting env list
clo9643[1] = kont9104;
clo9643[2] = proc;
clo9643[3] = lst;
void* f_lam_9106 = encode_clo(clo9643);



//clo-app
arg_buffer[1] = proc;
arg_buffer[2] = f_lam_9106;
arg_buffer[3] = apply_prim_car_1(lst);
numArgs = 3;
// generic else-case
reinterpret_cast<void (*)()>((decode_clo(proc))[0])();
}

}

inline void map_spec(void* _9235, void* kont9104, void* proc, void* lst) // map 
{
//decoding closure array
void** decode_clo_array = nullptr;

//if-clause
if(is_true(apply_prim_null_u63_1(lst)))
{
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(kont9104)[0])(kont9104, apply_prim_list_0());
}
else
{

//creating new make-kont closure
void** clo9644 = alloc_kont(lam9233_spec, 3);

//setting env list
clo9644[1] = kont9104;
clo9644[2] = proc;
clo9644[3] = lst;
void* f_lam_9106 = encode_clo(clo9644);



//clo-app
arg_buffer[1] = proc;
arg_buffer[2] = f_lam_9106;
arg_buffer[3] = apply_prim_car_1(lst);
numArgs = 3;
// generic else-case
reinterpret_cast<void (*)()>((decode_clo(proc))[0])();
}

}

inline void lam9236_fptr() // lam9236 -> generic version 
{
//reading env
void* const env9237 = arg_buffer[1];
//reading env and args
void* const id_8773 = arg_buffer[2];
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9237);
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(decode_clo_array[1])[0])(decode_clo_array[1], apply_prim_cons_2(decode_clo_array[2], id_8773));
}

inline void lam9236_spec(void* env9237, void* id_8773) // lam9236 
{
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9237);
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(decode_clo_array[1])[0])(decode_clo_array[1], apply_prim_cons_2(decode_clo_array[2], id_8773));
}

inline void lam9238_fptr() // lam9238 -> generic version 
{
//reading env
void* const env9239 = arg_buffer[1];
//reading env and args
void* const id_8770 = arg_buffer[2];
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9239);

//if-clause
if(is_true(id_8770))
{

//creating new make-kont closure
void** clo9645 = alloc_kont(lam9236_spec, 2);

//setting env list
clo9645[1] = decode_clo_array[3];
clo9645[2] = apply_prim_car_1(decode_clo_array[2]);
void* f_lam_9108 = encode_clo(clo9645);



//clo-app
filter_spec(filter, f_lam_9108, decode_clo_array[1], apply_prim_cdr_1(decode_clo_array[2]));
}
else
{

//clo-app
filter_spec(filter, decode_clo_array[3], decode_clo_array[1], apply_prim_cdr_1(decode_clo_array[2]));
}

}

inline void lam9238_spec(void* env9239, void* id_8770) // lam9238 
{
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9239);

//if-clause
if(is_true(id_8770))
{

//creating new make-kont closure
void** clo9646 = alloc_kont(lam9236_spec, 2);

//setting env list
clo9646[1] = decode_clo_array[3];
clo9646[2] = apply_prim_car_1(decode_clo_array[2]);
void* f_lam_9108 = encode_clo(clo9646);



//clo-app
filter_spec(filter, f_lam_9108, decode_clo_array[1], apply_prim_cdr_1(decode_clo_array[2]));
}
else
{

//clo-app
filter_spec(filter, decode_clo_array[3], decode_clo_array[1], apply_prim_cdr_1(decode_clo_array[2]));
}

}

inline void filter_fptr() // filter -> generic version 
{
//reading env and args
void* const kont9107 = arg_buffer[2];
void* const op = arg_buffer[3];
void* const lst = arg_buffer[4];
//decoding closure array
void** decode_clo_array = nullptr;

//if-clause
if(is_true(apply_prim_null_u63_1(lst)))
{
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(kont9107)[0])(kont9107, apply_prim_list_0());
}
else
{

//creating new make-kont closure
void** clo9647 = alloc_kont(lam9238_spec, 3);

//setting env list
clo9647[1] = op;
clo9647[2] = lst;
clo9647[3] = kont9107;
void* f_lam_9109 = encode_clo(clo9647);



//clo-app
arg_buffer[1] = op;
arg_buffer[2] = f_lam_9109;
arg_buffer[3] = apply_prim_car_1(lst);
numArgs = 3;
// generic else-case
reinterpret_cast<void (*)()>((decode_clo(op))[0])();
}

}

inline void filter_spec(void* _9240, void* kont9107, void* op, void* lst) // filter 
{
//decoding closure array
void** decode_clo_array = nullptr;

//if-clause
if(is_true(apply_prim_null_u63_1(lst)))
{
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(kont9107)[0])(kont9107, apply_prim_list_0());
}
else
{

//creating new make-kont closure
void** clo9648 = alloc_kont(lam9238_spec, 3);

//setting env list
clo9648[1] = op;
clo9648[2] = lst;
clo9648[3] = kont9107;
void* f_lam_9109 = encode_clo(clo9648);



//clo-app
arg_buffer[1] = op;
arg_buffer[2] = f_lam_9109;
arg_buffer[3] = apply_prim_car_1(lst);
numArgs = 3;
// generic else-case
reinterpret_cast<void (*)()>((decode_clo(op))[0])();
}

}

inline void drop_fptr() // drop -> generic version 
{
//reading env and args
void* const kont9110 = arg_buffer[2];
void* const lst = arg_buffer[3];
void* const n = arg_buffer[4];
//decoding closure array
void** decode_clo_array = nullptr;

//if-clause
if(is_true(apply_prim__u61_2(n, int9475)))
{
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(kont9110)[0])(kont9110, lst);
}
else
{

//clo-app
drop_spec(drop, kont9110, apply_prim_cdr_1(lst), apply_prim__u45_2(n, int9468));
}

}

inline void drop_spec(void* _9241, void* kont9110, void* lst, void* n) // drop 
{
//decoding closure array
void** decode_clo_array = nullptr;

//if-clause
if(is_true(apply_prim__u61_2(n, int9475)))
{
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(kont9110)[0])(kont9110, lst);
}
else
{

//clo-app
drop_spec(drop, kont9110, apply_prim_cdr_1(lst), apply_prim__u45_2(n, int9468));
}

}

inline void lam9242_fptr() // lam9242 -> generic version 
{
//reading env
void* const env9243 = arg_buffer[1];
//reading env and args
void* const id_8782 = arg_buffer[2];
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9243);

//clo-app
foldl_spec(foldl, decode_clo_array[2], decode_clo_array[1], id_8782, apply_prim_cdr_1(decode_clo_array[3]));
}

inline void lam9242_spec(void* env9243, void* id_8782) // lam9242 
{
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9243);

//clo-app
foldl_spec(foldl, decode_clo_array[2], decode_clo_array[1], id_8782, apply_prim_cdr_1(decode_clo_array[3]));
}

inline void foldl_fptr() // foldl -> generic version 
{
//reading env and args
void* const kont9111 = arg_buffer[2];
void* const fun = arg_buffer[3];
void* const acc = arg_buffer[4];
void* const lst = arg_buffer[5];
//decoding closure array
void** decode_clo_array = nullptr;

//if-clause
if(is_true(apply_prim_null_u63_1(lst)))
{
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(kont9111)[0])(kont9111, acc);
}
else
{

//creating new make-kont closure
void** clo9649 = alloc_kont(lam9242_spec, 3);

//setting env list
clo9649[1] = fun;
clo9649[2] = kont9111;
clo9649[3] = lst;
void* f_lam_9112 = encode_clo(clo9649);



//clo-app
arg_buffer[1] = fun;
arg_buffer[2] = f_lam_9112;
arg_buffer[3] = apply_prim_car_1(lst);
arg_buffer[4] = acc;
numArgs = 4;
// generic else-case
reinterpret_cast<void (*)()>((decode_clo(fun))[0])();
}

}

inline void foldl_spec(void* _9244, void* kont9111, void* fun, void* acc, void* lst) // foldl 
{
//decoding closure array
void** decode_clo_array = nullptr;

//if-clause
if(is_true(apply_prim_null_u63_1(lst)))
{
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(kont9111)[0])(kont9111, acc);
}
else
{

//creating new make-kont closure
void** clo9650 = alloc_kont(lam9242_spec, 3);

//setting env list
clo9650[1] = fun;
clo9650[2] = kont9111;
clo9650[3] = lst;
void* f_lam_9112 = encode_clo(clo9650);



//clo-app
arg_buffer[1] = fun;
arg_buffer[2] = f_lam_9112;
arg_buffer[3] = apply_prim_car_1(lst);
arg_buffer[4] = acc;
numArgs = 4;
// generic else-case
reinterpret_cast<void (*)()>((decode_clo(fun))[0])();
}

}

inline void lam9245_fptr() // lam9245 -> generic version 
{
//reading env
void* const env9246 = arg_buffer[1];
//reading env and args
void* const id_8787 = arg_buffer[2];
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9246);

//clo-app
arg_buffer[1] = decode_clo_array[1];
arg_buffer[2] = decode_clo_array[2];
arg_buffer[3] = decode_clo_array[3];
arg_buffer[4] = id_8787;
numArgs = 4;
// generic else-case
reinterpret_cast<void (*)()>((decode_clo(decode_clo_array[1]))[0])();
}

inline void lam9245_spec(void* env9246, void* id_8787) // lam9245 
{
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9246);

//clo-app
arg_buffer[1] = decode_clo_array[1];
arg_buffer[2] = decode_clo_array[2];
arg_buffer[3] = decode_clo_array[3];
arg_buffer[4] = id_8787;
numArgs = 4;
// generic else-case
reinterpret_cast<void (*)()>((decode_clo(decode_clo_array[1]))[0])();
}

inline void foldr_fptr() // foldr -> generic version 
{
//reading env and args
void* const kont9113 = arg_buffer[2];
void* const fun = arg_buffer[3];
void* const acc = arg_buffer[4];
void* const lst = arg_buffer[5];
//decoding closure array
void** decode_clo_array = nullptr;

//if-clause
if(is_true(apply_prim_null_u63_1(lst)))
{
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(kont9113)[0])(kont9113, acc);
}
else
{

//creating new make-kont closure
void** clo9651 = alloc_kont(lam9245_spec, 3);

//setting env list
clo9651[1] = fun;
clo9651[2] = kont9113;
clo9651[3] = apply_prim_car_1(lst);
void* f_lam_9114 = encode_clo(clo9651);



//clo-app
foldr_spec(foldr, f_lam_9114, fun, acc, apply_prim_cdr_1(lst));
}

}

inline void foldr_spec(void* _9247, void* kont9113, void* fun, void* acc, void* lst) // foldr 
{
//decoding closure array
void** decode_clo_array = nullptr;

//if-clause
if(is_true(apply_prim_null_u63_1(lst)))
{
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(kont9113)[0])(kont9113, acc);
}
else
{

//creating new make-kont closure
void** clo9652 = alloc_kont(lam9245_spec, 3);

//setting env list
clo9652[1] = fun;
clo9652[2] = kont9113;
clo9652[3] = apply_prim_car_1(lst);
void* f_lam_9114 = encode_clo(clo9652);



//clo-app
foldr_spec(foldr, f_lam_9114, fun, acc, apply_prim_cdr_1(lst));
}

}

inline void reverse_u45helper_fptr() // reverse-helper -> generic version 
{
//reading env and args
void* const kont9115 = arg_buffer[2];
void* const lst = arg_buffer[3];
void* const lst2 = arg_buffer[4];
//decoding closure array
void** decode_clo_array = nullptr;

//if-clause
if(is_true(apply_prim_null_u63_1(lst)))
{
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(kont9115)[0])(kont9115, lst2);
}
else
{

//clo-app
reverse_u45helper_spec(reverse_u45helper, kont9115, apply_prim_cdr_1(lst), apply_prim_cons_2(apply_prim_car_1(lst), lst2));
}

}

inline void reverse_u45helper_spec(void* _9248, void* kont9115, void* lst, void* lst2) // reverse-helper 
{
//decoding closure array
void** decode_clo_array = nullptr;

//if-clause
if(is_true(apply_prim_null_u63_1(lst)))
{
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(kont9115)[0])(kont9115, lst2);
}
else
{

//clo-app
reverse_u45helper_spec(reverse_u45helper, kont9115, apply_prim_cdr_1(lst), apply_prim_cons_2(apply_prim_car_1(lst), lst2));
}

}

inline void reverse_fptr() // reverse -> generic version 
{
//reading env and args
void* const kont9116 = arg_buffer[2];
void* const lst = arg_buffer[3];
//decoding closure array
void** decode_clo_array = nullptr;

//clo-app
reverse_u45helper_spec(reverse_u45helper, kont9116, lst, apply_prim_list_0());
}

inline void reverse_spec(void* _9249, void* kont9116, void* lst) // reverse 
{
//decoding closure array
void** decode_clo_array = nullptr;

//clo-app
reverse_u45helper_spec(reverse_u45helper, kont9116, lst, apply_prim_list_0());
}

inline void lam9250_fptr() // lam9250 -> generic version 
{
//reading env
void* const env9251 = arg_buffer[1];
//reading env and args
void* const id_8796 = arg_buffer[2];
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9251);
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(decode_clo_array[1])[0])(decode_clo_array[1], apply_prim_cons_2(decode_clo_array[2], id_8796));
}

inline void lam9250_spec(void* env9251, void* id_8796) // lam9250 
{
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9251);
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(decode_clo_array[1])[0])(decode_clo_array[1], apply_prim_cons_2(decode_clo_array[2], id_8796));
}

inline void append1_fptr() // append1 -> generic version 
{
//reading env and args
void* const kont9117 = arg_buffer[2];
void* const lhs = arg_buffer[3];
void* const rhs = arg_buffer[4];
//decoding closure array
void** decode_clo_array = nullptr;

//if-clause
if(is_true(apply_prim_null_u63_1(lhs)))
{
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(kont9117)[0])(kont9117, rhs);
}
else
{

//creating new make-kont closure
void** clo9653 = alloc_kont(lam9250_spec, 2);

//setting env list
clo9653[1] = kont9117;
clo9653[2] = apply_prim_car_1(lhs);
void* f_lam_9118 = encode_clo(clo9653);



//clo-app
append1_spec(append1, f_lam_9118, apply_prim_cdr_1(lhs), rhs);
}

}

inline void append1_spec(void* _9252, void* kont9117, void* lhs, void* rhs) // append1 
{
//decoding closure array
void** decode_clo_array = nullptr;

//if-clause
if(is_true(apply_prim_null_u63_1(lhs)))
{
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(kont9117)[0])(kont9117, rhs);
}
else
{

//creating new make-kont closure
void** clo9654 = alloc_kont(lam9250_spec, 2);

//setting env list
clo9654[1] = kont9117;
clo9654[2] = apply_prim_car_1(lhs);
void* f_lam_9118 = encode_clo(clo9654);



//clo-app
append1_spec(append1, f_lam_9118, apply_prim_cdr_1(lhs), rhs);
}

}

inline void lam9253_fptr() // lam9253 -> generic version 
{
//reading env
void* const env9254 = arg_buffer[1];
//reading env and args
void* const id_8803 = arg_buffer[2];
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9254);

//clo-app
foldr_spec(foldr, decode_clo_array[1], append1, decode_clo_array[2], id_8803);
}

inline void lam9253_spec(void* env9254, void* id_8803) // lam9253 
{
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9254);

//clo-app
foldr_spec(foldr, decode_clo_array[1], append1, decode_clo_array[2], id_8803);
}

inline void lam9255_fptr() // lam9255 -> generic version 
{
//reading env
void* const env9256 = arg_buffer[1];
//reading env and args
void* const id_8798 = arg_buffer[2];
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9256);

//if-clause
if(is_true(apply_prim__u61_2(decode_clo_array[3], id_8798)))
{

//clo-app
append1_spec(append1, decode_clo_array[2], decode_clo_array[1], apply_prim_car_1(decode_clo_array[4]));
}
else
{

//creating new make-kont closure
void** clo9655 = alloc_kont(lam9253_spec, 2);

//setting env list
clo9655[1] = decode_clo_array[2];
clo9655[2] = apply_prim_list_0();
void* f_lam_9120 = encode_clo(clo9655);



//clo-app
append1_spec(append1, f_lam_9120, apply_prim_list_1(decode_clo_array[1]), decode_clo_array[4]);
}

}

inline void lam9255_spec(void* env9256, void* id_8798) // lam9255 
{
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9256);

//if-clause
if(is_true(apply_prim__u61_2(decode_clo_array[3], id_8798)))
{

//clo-app
append1_spec(append1, decode_clo_array[2], decode_clo_array[1], apply_prim_car_1(decode_clo_array[4]));
}
else
{

//creating new make-kont closure
void** clo9656 = alloc_kont(lam9253_spec, 2);

//setting env list
clo9656[1] = decode_clo_array[2];
clo9656[2] = apply_prim_list_0();
void* f_lam_9120 = encode_clo(clo9656);



//clo-app
append1_spec(append1, f_lam_9120, apply_prim_list_1(decode_clo_array[1]), decode_clo_array[4]);
}

}

inline void lam9257_fptr() // lam9257 -> generic version 
{
//reading env
void* const env9258 = arg_buffer[1];
//reading env and args
void* const x = arg_buffer[2];
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9258);

//creating new make-kont closure
void** clo9657 = alloc_kont(lam9255_spec, 4);

//setting env list
clo9657[1] = decode_clo_array[1];
clo9657[2] = decode_clo_array[2];
clo9657[3] = int9468;
clo9657[4] = x;
void* f_lam_9121 = encode_clo(clo9657);



//clo-app
length_spec(length, f_lam_9121, x);
}

inline void lam9257_spec(void* env9258, void* x) // lam9257 
{
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9258);

//creating new make-kont closure
void** clo9658 = alloc_kont(lam9255_spec, 4);

//setting env list
clo9658[1] = decode_clo_array[1];
clo9658[2] = decode_clo_array[2];
clo9658[3] = int9468;
clo9658[4] = x;
void* f_lam_9121 = encode_clo(clo9658);



//clo-app
length_spec(length, f_lam_9121, x);
}

void append_fptr() // append 
{
//reading env
void* const _9259 = arg_buffer[1];
//decoding closure array
void** decode_clo_array = nullptr;
void* vargs = nullptr;
if(is_cons(arg_buffer[2]))
{
//(apply e0 e0) case
vargs = arg_buffer[2];
}
else
{
//building cons cell
vargs = encode_null();
for(int i = numArgs; i >= 2; i--)
{
vargs = prim_cons(arg_buffer[i], vargs);

}

}


//creating new make-kont closure
void** clo9659 = alloc_kont(lam9257_spec, 2);

//setting env list
clo9659[1] = apply_prim_car_1(apply_prim_cdr_1(vargs));
clo9659[2] = apply_prim_car_1(vargs);
void* f_lam_9122 = encode_clo(clo9659);


// kont-clo-app case
lam9257_spec(f_lam_9122, apply_prim_cdr_1(apply_prim_cdr_1(vargs)));
}

inline void lam9260_fptr() // lam9260 -> generic version 
{
//reading env
void* const env9261 = arg_buffer[1];
//reading env and args
void* const xy8806 = arg_buffer[2];
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9261);
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(decode_clo_array[1])[0])(decode_clo_array[1], xy8806);
}

inline void lam9260_spec(void* env9261, void* xy8806) // lam9260 
{
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9261);
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(decode_clo_array[1])[0])(decode_clo_array[1], xy8806);
}

inline void take_u45helper_fptr() // take-helper -> generic version 
{
//reading env and args
void* const kont9123 = arg_buffer[2];
void* const lst = arg_buffer[3];
void* const n = arg_buffer[4];
void* const lst2 = arg_buffer[5];
//decoding closure array
void** decode_clo_array = nullptr;

//if-clause
if(is_true(apply_prim__u61_2(n, int9475)))
{

//creating new make-kont closure
void** clo9660 = alloc_kont(lam9260_spec, 1);

//setting env list
clo9660[1] = kont9123;
void* f_lam_9124 = encode_clo(clo9660);



//clo-app
reverse_spec(reverse, f_lam_9124, lst2);
}
else
{

//clo-app
take_u45helper_spec(take_u45helper, kont9123, apply_prim_cdr_1(lst), apply_prim__u45_2(n, int9468), apply_prim_cons_2(apply_prim_car_1(lst), lst2));
}

}

inline void take_u45helper_spec(void* _9262, void* kont9123, void* lst, void* n, void* lst2) // take-helper 
{
//decoding closure array
void** decode_clo_array = nullptr;

//if-clause
if(is_true(apply_prim__u61_2(n, int9475)))
{

//creating new make-kont closure
void** clo9661 = alloc_kont(lam9260_spec, 1);

//setting env list
clo9661[1] = kont9123;
void* f_lam_9124 = encode_clo(clo9661);



//clo-app
reverse_spec(reverse, f_lam_9124, lst2);
}
else
{

//clo-app
take_u45helper_spec(take_u45helper, kont9123, apply_prim_cdr_1(lst), apply_prim__u45_2(n, int9468), apply_prim_cons_2(apply_prim_car_1(lst), lst2));
}

}

inline void take_fptr() // take -> generic version 
{
//reading env and args
void* const kont9125 = arg_buffer[2];
void* const lst = arg_buffer[3];
void* const n = arg_buffer[4];
//decoding closure array
void** decode_clo_array = nullptr;

//clo-app
take_u45helper_spec(take_u45helper, kont9125, lst, n, apply_prim_list_0());
}

inline void take_spec(void* _9263, void* kont9125, void* lst, void* n) // take 
{
//decoding closure array
void** decode_clo_array = nullptr;

//clo-app
take_u45helper_spec(take_u45helper, kont9125, lst, n, apply_prim_list_0());
}

inline void lam9264_fptr() // lam9264 -> generic version 
{
//reading env
void* const env9265 = arg_buffer[1];
//reading env and args
void* const id_8816 = arg_buffer[2];
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9265);

//clo-app
arg_buffer[1] = decode_clo_array[2];
arg_buffer[2] = decode_clo_array[1];
arg_buffer[3] = decode_clo_array[3];
arg_buffer[4] = id_8816;
numArgs = 4;
// generic else-case
reinterpret_cast<void (*)()>((decode_clo(decode_clo_array[2]))[0])();
}

inline void lam9264_spec(void* env9265, void* id_8816) // lam9264 
{
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9265);

//clo-app
arg_buffer[1] = decode_clo_array[2];
arg_buffer[2] = decode_clo_array[1];
arg_buffer[3] = decode_clo_array[3];
arg_buffer[4] = id_8816;
numArgs = 4;
// generic else-case
reinterpret_cast<void (*)()>((decode_clo(decode_clo_array[2]))[0])();
}

inline void my_u45foldr_u45aux_fptr() // my-foldr-aux -> generic version 
{
//reading env and args
void* const kont9126 = arg_buffer[2];
void* const lst = arg_buffer[3];
void* const f = arg_buffer[4];
void* const base = arg_buffer[5];
//decoding closure array
void** decode_clo_array = nullptr;

//if-clause
if(is_true(apply_prim_null_u63_1(lst)))
{
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(kont9126)[0])(kont9126, base);
}
else
{

//creating new make-kont closure
void** clo9662 = alloc_kont(lam9264_spec, 3);

//setting env list
clo9662[1] = kont9126;
clo9662[2] = f;
clo9662[3] = apply_prim_car_1(lst);
void* f_lam_9127 = encode_clo(clo9662);



//clo-app
my_u45foldr_u45aux_spec(my_u45foldr_u45aux, f_lam_9127, apply_prim_cdr_1(lst), f, base);
}

}

inline void my_u45foldr_u45aux_spec(void* _9266, void* kont9126, void* lst, void* f, void* base) // my-foldr-aux 
{
//decoding closure array
void** decode_clo_array = nullptr;

//if-clause
if(is_true(apply_prim_null_u63_1(lst)))
{
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(kont9126)[0])(kont9126, base);
}
else
{

//creating new make-kont closure
void** clo9663 = alloc_kont(lam9264_spec, 3);

//setting env list
clo9663[1] = kont9126;
clo9663[2] = f;
clo9663[3] = apply_prim_car_1(lst);
void* f_lam_9127 = encode_clo(clo9663);



//clo-app
my_u45foldr_u45aux_spec(my_u45foldr_u45aux, f_lam_9127, apply_prim_cdr_1(lst), f, base);
}

}

inline void lam9267_fptr() // lam9267 -> generic version 
{
//reading env
void* const env9268 = arg_buffer[1];
//reading env and args
void* const xy8817 = arg_buffer[2];
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9268);
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(decode_clo_array[1])[0])(decode_clo_array[1], xy8817);
}

inline void lam9267_spec(void* env9268, void* xy8817) // lam9267 
{
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9268);
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(decode_clo_array[1])[0])(decode_clo_array[1], xy8817);
}

inline void my_u45foldr_fptr() // my-foldr -> generic version 
{
//reading env and args
void* const kont9128 = arg_buffer[2];
void* const f = arg_buffer[3];
void* const base = arg_buffer[4];
void* const lst = arg_buffer[5];
//decoding closure array
void** decode_clo_array = nullptr;

//creating new make-kont closure
void** clo9664 = alloc_kont(lam9267_spec, 1);

//setting env list
clo9664[1] = kont9128;
void* f_lam_9129 = encode_clo(clo9664);



//clo-app
my_u45foldr_u45aux_spec(my_u45foldr_u45aux, f_lam_9129, lst, f, base);
}

inline void my_u45foldr_spec(void* _9269, void* kont9128, void* f, void* base, void* lst) // my-foldr 
{
//decoding closure array
void** decode_clo_array = nullptr;

//creating new make-kont closure
void** clo9665 = alloc_kont(lam9267_spec, 1);

//setting env list
clo9665[1] = kont9128;
void* f_lam_9129 = encode_clo(clo9665);



//clo-app
my_u45foldr_u45aux_spec(my_u45foldr_u45aux, f_lam_9129, lst, f, base);
}

inline void lam9270_fptr() // lam9270 -> generic version 
{
//reading env
void* const env9271 = arg_buffer[1];
//reading env and args
void* const id_8820 = arg_buffer[2];
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9271);

//clo-app
my_u45foldl_u45aux_spec(my_u45foldl_u45aux, decode_clo_array[1], decode_clo_array[2], id_8820, apply_prim_cdr_1(decode_clo_array[3]));
}

inline void lam9270_spec(void* env9271, void* id_8820) // lam9270 
{
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9271);

//clo-app
my_u45foldl_u45aux_spec(my_u45foldl_u45aux, decode_clo_array[1], decode_clo_array[2], id_8820, apply_prim_cdr_1(decode_clo_array[3]));
}

inline void my_u45foldl_u45aux_fptr() // my-foldl-aux -> generic version 
{
//reading env and args
void* const kont9130 = arg_buffer[2];
void* const f = arg_buffer[3];
void* const base = arg_buffer[4];
void* const lst = arg_buffer[5];
//decoding closure array
void** decode_clo_array = nullptr;

//if-clause
if(is_true(apply_prim_null_u63_1(lst)))
{
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(kont9130)[0])(kont9130, base);
}
else
{

//creating new make-kont closure
void** clo9666 = alloc_kont(lam9270_spec, 3);

//setting env list
clo9666[1] = kont9130;
clo9666[2] = f;
clo9666[3] = lst;
void* f_lam_9131 = encode_clo(clo9666);



//clo-app
arg_buffer[1] = f;
arg_buffer[2] = f_lam_9131;
arg_buffer[3] = base;
arg_buffer[4] = apply_prim_car_1(lst);
numArgs = 4;
// generic else-case
reinterpret_cast<void (*)()>((decode_clo(f))[0])();
}

}

inline void my_u45foldl_u45aux_spec(void* _9272, void* kont9130, void* f, void* base, void* lst) // my-foldl-aux 
{
//decoding closure array
void** decode_clo_array = nullptr;

//if-clause
if(is_true(apply_prim_null_u63_1(lst)))
{
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(kont9130)[0])(kont9130, base);
}
else
{

//creating new make-kont closure
void** clo9667 = alloc_kont(lam9270_spec, 3);

//setting env list
clo9667[1] = kont9130;
clo9667[2] = f;
clo9667[3] = lst;
void* f_lam_9131 = encode_clo(clo9667);



//clo-app
arg_buffer[1] = f;
arg_buffer[2] = f_lam_9131;
arg_buffer[3] = base;
arg_buffer[4] = apply_prim_car_1(lst);
numArgs = 4;
// generic else-case
reinterpret_cast<void (*)()>((decode_clo(f))[0])();
}

}

inline void lam9273_fptr() // lam9273 -> generic version 
{
//reading env
void* const env9274 = arg_buffer[1];
//reading env and args
void* const xy8822 = arg_buffer[2];
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9274);
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(decode_clo_array[1])[0])(decode_clo_array[1], xy8822);
}

inline void lam9273_spec(void* env9274, void* xy8822) // lam9273 
{
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9274);
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(decode_clo_array[1])[0])(decode_clo_array[1], xy8822);
}

inline void my_u45foldl_fptr() // my-foldl -> generic version 
{
//reading env and args
void* const kont9132 = arg_buffer[2];
void* const f = arg_buffer[3];
void* const base = arg_buffer[4];
void* const lst = arg_buffer[5];
//decoding closure array
void** decode_clo_array = nullptr;

//creating new make-kont closure
void** clo9668 = alloc_kont(lam9273_spec, 1);

//setting env list
clo9668[1] = kont9132;
void* f_lam_9133 = encode_clo(clo9668);



//clo-app
my_u45foldl_u45aux_spec(my_u45foldl_u45aux, f_lam_9133, f, base, lst);
}

inline void my_u45foldl_spec(void* _9275, void* kont9132, void* f, void* base, void* lst) // my-foldl 
{
//decoding closure array
void** decode_clo_array = nullptr;

//creating new make-kont closure
void** clo9669 = alloc_kont(lam9273_spec, 1);

//setting env list
clo9669[1] = kont9132;
void* f_lam_9133 = encode_clo(clo9669);



//clo-app
my_u45foldl_u45aux_spec(my_u45foldl_u45aux, f_lam_9133, f, base, lst);
}

inline void lam9276_fptr() // lam9276 -> generic version 
{
//reading env
void* const env9277 = arg_buffer[1];
//reading env and args
void* const id_8827 = arg_buffer[2];
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9277);
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(decode_clo_array[1])[0])(decode_clo_array[1], apply_prim_cons_2(decode_clo_array[2], id_8827));
}

inline void lam9276_spec(void* env9277, void* id_8827) // lam9276 
{
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9277);
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(decode_clo_array[1])[0])(decode_clo_array[1], apply_prim_cons_2(decode_clo_array[2], id_8827));
}

inline void lam9278_fptr() // lam9278 -> generic version 
{
//reading env
void* const env9279 = arg_buffer[1];
//reading env and args
void* const id_8824 = arg_buffer[2];
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9279);

//creating new make-kont closure
void** clo9670 = alloc_kont(lam9276_spec, 2);

//setting env list
clo9670[1] = decode_clo_array[1];
clo9670[2] = id_8824;
void* f_lam_9135 = encode_clo(clo9670);



//clo-app
my_u45for_u45aux_spec(my_u45for_u45aux, f_lam_9135, apply_prim__u43_2(decode_clo_array[3], int9468), decode_clo_array[2], decode_clo_array[4]);
}

inline void lam9278_spec(void* env9279, void* id_8824) // lam9278 
{
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9279);

//creating new make-kont closure
void** clo9671 = alloc_kont(lam9276_spec, 2);

//setting env list
clo9671[1] = decode_clo_array[1];
clo9671[2] = id_8824;
void* f_lam_9135 = encode_clo(clo9671);



//clo-app
my_u45for_u45aux_spec(my_u45for_u45aux, f_lam_9135, apply_prim__u43_2(decode_clo_array[3], int9468), decode_clo_array[2], decode_clo_array[4]);
}

inline void my_u45for_u45aux_fptr() // my-for-aux -> generic version 
{
//reading env and args
void* const kont9134 = arg_buffer[2];
void* const lo = arg_buffer[3];
void* const hi = arg_buffer[4];
void* const f = arg_buffer[5];
//decoding closure array
void** decode_clo_array = nullptr;

//if-clause
if(is_true(apply_prim__u60_2(lo, hi)))
{

//creating new make-kont closure
void** clo9672 = alloc_kont(lam9278_spec, 4);

//setting env list
clo9672[1] = kont9134;
clo9672[2] = hi;
clo9672[3] = lo;
clo9672[4] = f;
void* f_lam_9136 = encode_clo(clo9672);



//clo-app
arg_buffer[1] = f;
arg_buffer[2] = f_lam_9136;
arg_buffer[3] = lo;
numArgs = 3;
// generic else-case
reinterpret_cast<void (*)()>((decode_clo(f))[0])();
}
else
{
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(kont9134)[0])(kont9134, apply_prim_list_0());
}

}

inline void my_u45for_u45aux_spec(void* _9280, void* kont9134, void* lo, void* hi, void* f) // my-for-aux 
{
//decoding closure array
void** decode_clo_array = nullptr;

//if-clause
if(is_true(apply_prim__u60_2(lo, hi)))
{

//creating new make-kont closure
void** clo9673 = alloc_kont(lam9278_spec, 4);

//setting env list
clo9673[1] = kont9134;
clo9673[2] = hi;
clo9673[3] = lo;
clo9673[4] = f;
void* f_lam_9136 = encode_clo(clo9673);



//clo-app
arg_buffer[1] = f;
arg_buffer[2] = f_lam_9136;
arg_buffer[3] = lo;
numArgs = 3;
// generic else-case
reinterpret_cast<void (*)()>((decode_clo(f))[0])();
}
else
{
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(kont9134)[0])(kont9134, apply_prim_list_0());
}

}

inline void lam9281_fptr() // lam9281 -> generic version 
{
//reading env
void* const env9282 = arg_buffer[1];
//reading env and args
void* const xy8829 = arg_buffer[2];
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9282);
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(decode_clo_array[1])[0])(decode_clo_array[1], xy8829);
}

inline void lam9281_spec(void* env9282, void* xy8829) // lam9281 
{
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9282);
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(decode_clo_array[1])[0])(decode_clo_array[1], xy8829);
}

inline void my_u45for_fptr() // my-for -> generic version 
{
//reading env and args
void* const kont9137 = arg_buffer[2];
void* const lo = arg_buffer[3];
void* const hi = arg_buffer[4];
void* const f = arg_buffer[5];
//decoding closure array
void** decode_clo_array = nullptr;

//creating new make-kont closure
void** clo9674 = alloc_kont(lam9281_spec, 1);

//setting env list
clo9674[1] = kont9137;
void* f_lam_9138 = encode_clo(clo9674);



//clo-app
my_u45for_u45aux_spec(my_u45for_u45aux, f_lam_9138, lo, hi, f);
}

inline void my_u45for_spec(void* _9283, void* kont9137, void* lo, void* hi, void* f) // my-for 
{
//decoding closure array
void** decode_clo_array = nullptr;

//creating new make-kont closure
void** clo9675 = alloc_kont(lam9281_spec, 1);

//setting env list
clo9675[1] = kont9137;
void* f_lam_9138 = encode_clo(clo9675);



//clo-app
my_u45for_u45aux_spec(my_u45for_u45aux, f_lam_9138, lo, hi, f);
}

inline void concat_fptr() // concat -> generic version 
{
//reading env and args
void* const kont9139 = arg_buffer[2];
void* const lists = arg_buffer[3];
//decoding closure array
void** decode_clo_array = nullptr;

//clo-app
my_u45foldr_spec(my_u45foldr, kont9139, append, apply_prim_list_0(), lists);
}

inline void concat_spec(void* _9284, void* kont9139, void* lists) // concat 
{
//decoding closure array
void** decode_clo_array = nullptr;

//clo-app
my_u45foldr_spec(my_u45foldr, kont9139, append, apply_prim_list_0(), lists);
}

inline void list_u45read_fptr() // list-read -> generic version 
{
//reading env and args
void* const kont9140 = arg_buffer[2];
void* const lst = arg_buffer[3];
void* const i = arg_buffer[4];
//decoding closure array
void** decode_clo_array = nullptr;

//if-clause
if(is_true(apply_prim__u61_2(i, int9475)))
{
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(kont9140)[0])(kont9140, apply_prim_car_1(lst));
}
else
{

//clo-app
list_u45read_spec(list_u45read, kont9140, apply_prim_cdr_1(lst), apply_prim__u45_2(i, int9468));
}

}

inline void list_u45read_spec(void* _9285, void* kont9140, void* lst, void* i) // list-read 
{
//decoding closure array
void** decode_clo_array = nullptr;

//if-clause
if(is_true(apply_prim__u61_2(i, int9475)))
{
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(kont9140)[0])(kont9140, apply_prim_car_1(lst));
}
else
{

//clo-app
list_u45read_spec(list_u45read, kont9140, apply_prim_cdr_1(lst), apply_prim__u45_2(i, int9468));
}

}

inline void lam9286_fptr() // lam9286 -> generic version 
{
//reading env
void* const env9287 = arg_buffer[1];
//reading env and args
void* const id_8844 = arg_buffer[2];
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9287);
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(decode_clo_array[2])[0])(decode_clo_array[2], apply_prim_cons_2(decode_clo_array[1], id_8844));
}

inline void lam9286_spec(void* env9287, void* id_8844) // lam9286 
{
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9287);
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(decode_clo_array[2])[0])(decode_clo_array[2], apply_prim_cons_2(decode_clo_array[1], id_8844));
}

inline void list_u45write_fptr() // list-write -> generic version 
{
//reading env and args
void* const kont9141 = arg_buffer[2];
void* const lst = arg_buffer[3];
void* const i = arg_buffer[4];
void* const val = arg_buffer[5];
//decoding closure array
void** decode_clo_array = nullptr;

//if-clause
if(is_true(apply_prim__u61_2(i, int9475)))
{
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(kont9141)[0])(kont9141, apply_prim_cons_2(val, apply_prim_cdr_1(lst)));
}
else
{

//creating new make-kont closure
void** clo9676 = alloc_kont(lam9286_spec, 2);

//setting env list
clo9676[1] = apply_prim_car_1(lst);
clo9676[2] = kont9141;
void* f_lam_9142 = encode_clo(clo9676);



//clo-app
list_u45write_spec(list_u45write, f_lam_9142, apply_prim_cdr_1(lst), apply_prim__u45_2(i, int9468), val);
}

}

inline void list_u45write_spec(void* _9288, void* kont9141, void* lst, void* i, void* val) // list-write 
{
//decoding closure array
void** decode_clo_array = nullptr;

//if-clause
if(is_true(apply_prim__u61_2(i, int9475)))
{
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(kont9141)[0])(kont9141, apply_prim_cons_2(val, apply_prim_cdr_1(lst)));
}
else
{

//creating new make-kont closure
void** clo9677 = alloc_kont(lam9286_spec, 2);

//setting env list
clo9677[1] = apply_prim_car_1(lst);
clo9677[2] = kont9141;
void* f_lam_9142 = encode_clo(clo9677);



//clo-app
list_u45write_spec(list_u45write, f_lam_9142, apply_prim_cdr_1(lst), apply_prim__u45_2(i, int9468), val);
}

}

inline void lam9289_fptr() // lam9289 -> generic version 
{
//reading env
void* const env9290 = arg_buffer[1];
//reading env and args
void* const id_8852 = arg_buffer[2];
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9290);
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(decode_clo_array[2])[0])(decode_clo_array[2], apply_prim_cons_2(decode_clo_array[1], id_8852));
}

inline void lam9289_spec(void* env9290, void* id_8852) // lam9289 
{
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9290);
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(decode_clo_array[2])[0])(decode_clo_array[2], apply_prim_cons_2(decode_clo_array[1], id_8852));
}

inline void list_u45remove_u45pos_fptr() // list-remove-pos -> generic version 
{
//reading env and args
void* const kont9143 = arg_buffer[2];
void* const lst = arg_buffer[3];
void* const i = arg_buffer[4];
//decoding closure array
void** decode_clo_array = nullptr;

//if-clause
if(is_true(apply_prim__u61_2(i, int9475)))
{
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(kont9143)[0])(kont9143, apply_prim_cdr_1(lst));
}
else
{

//creating new make-kont closure
void** clo9678 = alloc_kont(lam9289_spec, 2);

//setting env list
clo9678[1] = apply_prim_car_1(lst);
clo9678[2] = kont9143;
void* f_lam_9144 = encode_clo(clo9678);



//clo-app
list_u45remove_u45pos_spec(list_u45remove_u45pos, f_lam_9144, apply_prim_cdr_1(lst), apply_prim__u45_2(i, int9468));
}

}

inline void list_u45remove_u45pos_spec(void* _9291, void* kont9143, void* lst, void* i) // list-remove-pos 
{
//decoding closure array
void** decode_clo_array = nullptr;

//if-clause
if(is_true(apply_prim__u61_2(i, int9475)))
{
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(kont9143)[0])(kont9143, apply_prim_cdr_1(lst));
}
else
{

//creating new make-kont closure
void** clo9679 = alloc_kont(lam9289_spec, 2);

//setting env list
clo9679[1] = apply_prim_car_1(lst);
clo9679[2] = kont9143;
void* f_lam_9144 = encode_clo(clo9679);



//clo-app
list_u45remove_u45pos_spec(list_u45remove_u45pos, f_lam_9144, apply_prim_cdr_1(lst), apply_prim__u45_2(i, int9468));
}

}

inline void lam9292_fptr() // lam9292 -> generic version 
{
//reading env
void* const env9293 = arg_buffer[1];
//reading env and args
void* const id_8857 = arg_buffer[2];
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9293);

//if-clause
if(is_true(id_8857))
{

//clo-app
member_spec(member, decode_clo_array[1], apply_prim_car_1(decode_clo_array[2]), apply_prim_cdr_1(decode_clo_array[2]));
}
else
{

//clo-app
duplicates_u63_spec(duplicates_u63, decode_clo_array[1], apply_prim_cdr_1(decode_clo_array[2]));
}

}

inline void lam9292_spec(void* env9293, void* id_8857) // lam9292 
{
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9293);

//if-clause
if(is_true(id_8857))
{

//clo-app
member_spec(member, decode_clo_array[1], apply_prim_car_1(decode_clo_array[2]), apply_prim_cdr_1(decode_clo_array[2]));
}
else
{

//clo-app
duplicates_u63_spec(duplicates_u63, decode_clo_array[1], apply_prim_cdr_1(decode_clo_array[2]));
}

}

inline void duplicates_u63_fptr() // duplicates? -> generic version 
{
//reading env and args
void* const kont9145 = arg_buffer[2];
void* const lst = arg_buffer[3];
//decoding closure array
void** decode_clo_array = nullptr;

//if-clause
if(is_true(apply_prim_null_u63_1(lst)))
{
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(kont9145)[0])(kont9145, bool_f9473);
}
else
{

//creating new make-kont closure
void** clo9680 = alloc_kont(lam9292_spec, 2);

//setting env list
clo9680[1] = kont9145;
clo9680[2] = lst;
void* f_lam_9146 = encode_clo(clo9680);



//clo-app
member_spec(member, f_lam_9146, apply_prim_car_1(lst), apply_prim_cdr_1(lst));
}

}

inline void duplicates_u63_spec(void* _9294, void* kont9145, void* lst) // duplicates? 
{
//decoding closure array
void** decode_clo_array = nullptr;

//if-clause
if(is_true(apply_prim_null_u63_1(lst)))
{
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(kont9145)[0])(kont9145, bool_f9473);
}
else
{

//creating new make-kont closure
void** clo9681 = alloc_kont(lam9292_spec, 2);

//setting env list
clo9681[1] = kont9145;
clo9681[2] = lst;
void* f_lam_9146 = encode_clo(clo9681);



//clo-app
member_spec(member, f_lam_9146, apply_prim_car_1(lst), apply_prim_cdr_1(lst));
}

}

inline void lam9295_fptr() // lam9295 -> generic version 
{
//reading env
void* const env9296 = arg_buffer[1];
//reading env and args
void* const cont9149 = arg_buffer[2];
void* const j = arg_buffer[3];
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9296);

//clo-app
arg_buffer[1] = decode_clo_array[2];
arg_buffer[2] = cont9149;
arg_buffer[3] = decode_clo_array[1];
arg_buffer[4] = j;
numArgs = 4;
// generic else-case
reinterpret_cast<void (*)()>((decode_clo(decode_clo_array[2]))[0])();
}

inline void lam9295_spec(void* env9296, void* cont9149, void* j) // lam9295 
{
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9296);

//clo-app
arg_buffer[1] = decode_clo_array[2];
arg_buffer[2] = cont9149;
arg_buffer[3] = decode_clo_array[1];
arg_buffer[4] = j;
numArgs = 4;
// generic else-case
reinterpret_cast<void (*)()>((decode_clo(decode_clo_array[2]))[0])();
}

inline void lam9297_fptr() // lam9297 -> generic version 
{
//reading env
void* const env9298 = arg_buffer[1];
//reading env and args
void* const cont9148 = arg_buffer[2];
void* const i = arg_buffer[3];
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9298);

//creating new closure instance
void** clo9682 = alloc_clo(lam9295_fptr, 2);

//setting env list
clo9682[1] = i;
clo9682[2] = decode_clo_array[2];
void* id_8863 = encode_clo(clo9682);



//clo-app
my_u45for_spec(my_u45for, cont9148, int9475, decode_clo_array[1], id_8863);
}

inline void lam9297_spec(void* env9298, void* cont9148, void* i) // lam9297 
{
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9298);

//creating new closure instance
void** clo9683 = alloc_clo(lam9295_fptr, 2);

//setting env list
clo9683[1] = i;
clo9683[2] = decode_clo_array[2];
void* id_8863 = encode_clo(clo9683);



//clo-app
my_u45for_spec(my_u45for, cont9148, int9475, decode_clo_array[1], id_8863);
}

inline void make_u45matrix_fptr() // make-matrix -> generic version 
{
//reading env and args
void* const kont9147 = arg_buffer[2];
void* const n = arg_buffer[3];
void* const m = arg_buffer[4];
void* const init = arg_buffer[5];
//decoding closure array
void** decode_clo_array = nullptr;

//creating new closure instance
void** clo9684 = alloc_clo(lam9297_fptr, 2);

//setting env list
clo9684[1] = m;
clo9684[2] = init;
void* id_8864 = encode_clo(clo9684);



//clo-app
my_u45for_spec(my_u45for, kont9147, int9475, n, id_8864);
}

inline void make_u45matrix_spec(void* _9299, void* kont9147, void* n, void* m, void* init) // make-matrix 
{
//decoding closure array
void** decode_clo_array = nullptr;

//creating new closure instance
void** clo9685 = alloc_clo(lam9297_fptr, 2);

//setting env list
clo9685[1] = m;
clo9685[2] = init;
void* id_8864 = encode_clo(clo9685);



//clo-app
my_u45for_spec(my_u45for, kont9147, int9475, n, id_8864);
}

inline void lam9300_fptr() // lam9300 -> generic version 
{
//reading env
void* const env9301 = arg_buffer[1];
//reading env and args
void* const id_8865 = arg_buffer[2];
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9301);

//clo-app
list_u45read_spec(list_u45read, decode_clo_array[1], id_8865, decode_clo_array[2]);
}

inline void lam9300_spec(void* env9301, void* id_8865) // lam9300 
{
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9301);

//clo-app
list_u45read_spec(list_u45read, decode_clo_array[1], id_8865, decode_clo_array[2]);
}

inline void matrix_u45read_fptr() // matrix-read -> generic version 
{
//reading env and args
void* const kont9150 = arg_buffer[2];
void* const mat = arg_buffer[3];
void* const i = arg_buffer[4];
void* const j = arg_buffer[5];
//decoding closure array
void** decode_clo_array = nullptr;

//creating new make-kont closure
void** clo9686 = alloc_kont(lam9300_spec, 2);

//setting env list
clo9686[1] = kont9150;
clo9686[2] = j;
void* f_lam_9151 = encode_clo(clo9686);



//clo-app
list_u45read_spec(list_u45read, f_lam_9151, mat, i);
}

inline void matrix_u45read_spec(void* _9302, void* kont9150, void* mat, void* i, void* j) // matrix-read 
{
//decoding closure array
void** decode_clo_array = nullptr;

//creating new make-kont closure
void** clo9687 = alloc_kont(lam9300_spec, 2);

//setting env list
clo9687[1] = kont9150;
clo9687[2] = j;
void* f_lam_9151 = encode_clo(clo9687);



//clo-app
list_u45read_spec(list_u45read, f_lam_9151, mat, i);
}

inline void lam9303_fptr() // lam9303 -> generic version 
{
//reading env
void* const env9304 = arg_buffer[1];
//reading env and args
void* const id_8867 = arg_buffer[2];
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9304);

//clo-app
list_u45write_spec(list_u45write, decode_clo_array[1], decode_clo_array[3], decode_clo_array[2], id_8867);
}

inline void lam9303_spec(void* env9304, void* id_8867) // lam9303 
{
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9304);

//clo-app
list_u45write_spec(list_u45write, decode_clo_array[1], decode_clo_array[3], decode_clo_array[2], id_8867);
}

inline void lam9305_fptr() // lam9305 -> generic version 
{
//reading env
void* const env9306 = arg_buffer[1];
//reading env and args
void* const id_8866 = arg_buffer[2];
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9306);

//creating new make-kont closure
void** clo9688 = alloc_kont(lam9303_spec, 3);

//setting env list
clo9688[1] = decode_clo_array[1];
clo9688[2] = decode_clo_array[2];
clo9688[3] = decode_clo_array[5];
void* f_lam_9153 = encode_clo(clo9688);



//clo-app
list_u45write_spec(list_u45write, f_lam_9153, id_8866, decode_clo_array[3], decode_clo_array[4]);
}

inline void lam9305_spec(void* env9306, void* id_8866) // lam9305 
{
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9306);

//creating new make-kont closure
void** clo9689 = alloc_kont(lam9303_spec, 3);

//setting env list
clo9689[1] = decode_clo_array[1];
clo9689[2] = decode_clo_array[2];
clo9689[3] = decode_clo_array[5];
void* f_lam_9153 = encode_clo(clo9689);



//clo-app
list_u45write_spec(list_u45write, f_lam_9153, id_8866, decode_clo_array[3], decode_clo_array[4]);
}

inline void matrix_u45write_fptr() // matrix-write -> generic version 
{
//reading env and args
void* const kont9152 = arg_buffer[2];
void* const mat = arg_buffer[3];
void* const i = arg_buffer[4];
void* const j = arg_buffer[5];
void* const val = arg_buffer[6];
//decoding closure array
void** decode_clo_array = nullptr;

//creating new make-kont closure
void** clo9690 = alloc_kont(lam9305_spec, 5);

//setting env list
clo9690[1] = kont9152;
clo9690[2] = i;
clo9690[3] = j;
clo9690[4] = val;
clo9690[5] = mat;
void* f_lam_9154 = encode_clo(clo9690);



//clo-app
list_u45read_spec(list_u45read, f_lam_9154, mat, i);
}

inline void matrix_u45write_spec(void* _9307, void* kont9152, void* mat, void* i, void* j, void* val) // matrix-write 
{
//decoding closure array
void** decode_clo_array = nullptr;

//creating new make-kont closure
void** clo9691 = alloc_kont(lam9305_spec, 5);

//setting env list
clo9691[1] = kont9152;
clo9691[2] = i;
clo9691[3] = j;
clo9691[4] = val;
clo9691[5] = mat;
void* f_lam_9154 = encode_clo(clo9691);



//clo-app
list_u45read_spec(list_u45read, f_lam_9154, mat, i);
}

inline void lam9308_fptr() // lam9308 -> generic version 
{
//reading env
void* const env9309 = arg_buffer[1];
//reading env and args
void* const id_8870 = arg_buffer[2];
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9309);
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(decode_clo_array[2])[0])(decode_clo_array[2], apply_prim_cons_2(decode_clo_array[1], id_8870));
}

inline void lam9308_spec(void* env9309, void* id_8870) // lam9308 
{
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9309);
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(decode_clo_array[2])[0])(decode_clo_array[2], apply_prim_cons_2(decode_clo_array[1], id_8870));
}

inline void lam9310_fptr() // lam9310 -> generic version 
{
//reading env
void* const env9311 = arg_buffer[1];
//reading env and args
void* const id_8868 = arg_buffer[2];
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9311);

//creating new make-kont closure
void** clo9692 = alloc_kont(lam9308_spec, 2);

//setting env list
clo9692[1] = id_8868;
clo9692[2] = decode_clo_array[1];
void* f_lam_9156 = encode_clo(clo9692);



//clo-app
length_spec(length, f_lam_9156, apply_prim_car_1(decode_clo_array[2]));
}

inline void lam9310_spec(void* env9311, void* id_8868) // lam9310 
{
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9311);

//creating new make-kont closure
void** clo9693 = alloc_kont(lam9308_spec, 2);

//setting env list
clo9693[1] = id_8868;
clo9693[2] = decode_clo_array[1];
void* f_lam_9156 = encode_clo(clo9693);



//clo-app
length_spec(length, f_lam_9156, apply_prim_car_1(decode_clo_array[2]));
}

inline void matrix_u45size_fptr() // matrix-size -> generic version 
{
//reading env and args
void* const kont9155 = arg_buffer[2];
void* const mat = arg_buffer[3];
//decoding closure array
void** decode_clo_array = nullptr;

//creating new make-kont closure
void** clo9694 = alloc_kont(lam9310_spec, 2);

//setting env list
clo9694[1] = kont9155;
clo9694[2] = mat;
void* f_lam_9157 = encode_clo(clo9694);



//clo-app
length_spec(length, f_lam_9157, mat);
}

inline void matrix_u45size_spec(void* _9312, void* kont9155, void* mat) // matrix-size 
{
//decoding closure array
void** decode_clo_array = nullptr;

//creating new make-kont closure
void** clo9695 = alloc_kont(lam9310_spec, 2);

//setting env list
clo9695[1] = kont9155;
clo9695[2] = mat;
void* f_lam_9157 = encode_clo(clo9695);



//clo-app
length_spec(length, f_lam_9157, mat);
}

inline void lam9313_fptr() // lam9313 -> generic version 
{
//reading env
void* const env9314 = arg_buffer[1];
//reading env and args
void* const cont9159 = arg_buffer[2];
void* const lst = arg_buffer[3];
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9314);

//clo-app
map_spec(map, cont9159, decode_clo_array[1], lst);
}

inline void lam9313_spec(void* env9314, void* cont9159, void* lst) // lam9313 
{
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9314);

//clo-app
map_spec(map, cont9159, decode_clo_array[1], lst);
}

inline void matrix_u45map_fptr() // matrix-map -> generic version 
{
//reading env and args
void* const kont9158 = arg_buffer[2];
void* const f = arg_buffer[3];
void* const mat = arg_buffer[4];
//decoding closure array
void** decode_clo_array = nullptr;

//creating new closure instance
void** clo9696 = alloc_clo(lam9313_fptr, 1);

//setting env list
clo9696[1] = f;
void* id_8871 = encode_clo(clo9696);



//clo-app
map_spec(map, kont9158, id_8871, mat);
}

inline void matrix_u45map_spec(void* _9315, void* kont9158, void* f, void* mat) // matrix-map 
{
//decoding closure array
void** decode_clo_array = nullptr;

//creating new closure instance
void** clo9697 = alloc_clo(lam9313_fptr, 1);

//setting env list
clo9697[1] = f;
void* id_8871 = encode_clo(clo9697);



//clo-app
map_spec(map, kont9158, id_8871, mat);
}

inline void initial_u45random_fptr() // initial-random -> generic version 
{
//reading env and args
void* const kont9160 = arg_buffer[2];
//decoding closure array
void** decode_clo_array = nullptr;
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(kont9160)[0])(kont9160, int9475);
}

inline void initial_u45random_spec(void* _9316, void* kont9160) // initial-random 
{
//decoding closure array
void** decode_clo_array = nullptr;
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(kont9160)[0])(kont9160, int9475);
}

inline void next_u45random_fptr() // next-random -> generic version 
{
//reading env and args
void* const kont9161 = arg_buffer[2];
void* const current_u45random = arg_buffer[3];
//decoding closure array
void** decode_clo_array = nullptr;
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(kont9161)[0])(kont9161, apply_prim_remainder_2(apply_prim__u43_2(apply_prim__u42_2(current_u45random, int9450), int9451), int9452));
}

inline void next_u45random_spec(void* _9317, void* kont9161, void* current_u45random) // next-random 
{
//decoding closure array
void** decode_clo_array = nullptr;
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(kont9161)[0])(kont9161, apply_prim_remainder_2(apply_prim__u43_2(apply_prim__u42_2(current_u45random, int9450), int9451), int9452));
}

inline void lam9318_fptr() // lam9318 -> generic version 
{
//reading env
void* const env9319 = arg_buffer[1];
//reading env and args
void* const id_8880 = arg_buffer[2];
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9319);
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(decode_clo_array[1])[0])(decode_clo_array[1], apply_prim_remainder_2(decode_clo_array[2], id_8880));
}

inline void lam9318_spec(void* env9319, void* id_8880) // lam9318 
{
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9319);
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(decode_clo_array[1])[0])(decode_clo_array[1], apply_prim_remainder_2(decode_clo_array[2], id_8880));
}

inline void lam9320_fptr() // lam9320 -> generic version 
{
//reading env
void* const env9321 = arg_buffer[1];
//reading env and args
void* const id_8883 = arg_buffer[2];
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9321);
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(decode_clo_array[1])[0])(decode_clo_array[1], apply_prim_cons_2(decode_clo_array[2], id_8883));
}

inline void lam9320_spec(void* env9321, void* id_8883) // lam9320 
{
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9321);
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(decode_clo_array[1])[0])(decode_clo_array[1], apply_prim_cons_2(decode_clo_array[2], id_8883));
}

inline void lam9322_fptr() // lam9322 -> generic version 
{
//reading env
void* const env9323 = arg_buffer[1];
//reading env and args
void* const id_8882 = arg_buffer[2];
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9323);

//creating new make-kont closure
void** clo9698 = alloc_kont(lam9320_spec, 2);

//setting env list
clo9698[1] = decode_clo_array[2];
clo9698[2] = decode_clo_array[3];
void* f_lam_9163 = encode_clo(clo9698);



//clo-app
shuffle_u45aux_spec(shuffle_u45aux, f_lam_9163, id_8882, decode_clo_array[1]);
}

inline void lam9322_spec(void* env9323, void* id_8882) // lam9322 
{
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9323);

//creating new make-kont closure
void** clo9699 = alloc_kont(lam9320_spec, 2);

//setting env list
clo9699[1] = decode_clo_array[2];
clo9699[2] = decode_clo_array[3];
void* f_lam_9163 = encode_clo(clo9699);



//clo-app
shuffle_u45aux_spec(shuffle_u45aux, f_lam_9163, id_8882, decode_clo_array[1]);
}

inline void lam9324_fptr() // lam9324 -> generic version 
{
//reading env
void* const env9325 = arg_buffer[1];
//reading env and args
void* const id_8881 = arg_buffer[2];
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9325);

//creating new make-kont closure
void** clo9700 = alloc_kont(lam9322_spec, 3);

//setting env list
clo9700[1] = decode_clo_array[1];
clo9700[2] = decode_clo_array[3];
clo9700[3] = id_8881;
void* f_lam_9164 = encode_clo(clo9700);



//clo-app
list_u45remove_u45pos_spec(list_u45remove_u45pos, f_lam_9164, decode_clo_array[4], decode_clo_array[2]);
}

inline void lam9324_spec(void* env9325, void* id_8881) // lam9324 
{
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9325);

//creating new make-kont closure
void** clo9701 = alloc_kont(lam9322_spec, 3);

//setting env list
clo9701[1] = decode_clo_array[1];
clo9701[2] = decode_clo_array[3];
clo9701[3] = id_8881;
void* f_lam_9164 = encode_clo(clo9701);



//clo-app
list_u45remove_u45pos_spec(list_u45remove_u45pos, f_lam_9164, decode_clo_array[4], decode_clo_array[2]);
}

inline void lam9326_fptr() // lam9326 -> generic version 
{
//reading env
void* const env9327 = arg_buffer[1];
//reading env and args
void* const i = arg_buffer[2];
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9327);

//creating new make-kont closure
void** clo9702 = alloc_kont(lam9324_spec, 4);

//setting env list
clo9702[1] = decode_clo_array[1];
clo9702[2] = i;
clo9702[3] = decode_clo_array[2];
clo9702[4] = decode_clo_array[3];
void* f_lam_9165 = encode_clo(clo9702);



//clo-app
list_u45read_spec(list_u45read, f_lam_9165, decode_clo_array[3], i);
}

inline void lam9326_spec(void* env9327, void* i) // lam9326 
{
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9327);

//creating new make-kont closure
void** clo9703 = alloc_kont(lam9324_spec, 4);

//setting env list
clo9703[1] = decode_clo_array[1];
clo9703[2] = i;
clo9703[3] = decode_clo_array[2];
clo9703[4] = decode_clo_array[3];
void* f_lam_9165 = encode_clo(clo9703);



//clo-app
list_u45read_spec(list_u45read, f_lam_9165, decode_clo_array[3], i);
}

inline void lam9328_fptr() // lam9328 -> generic version 
{
//reading env
void* const env9329 = arg_buffer[1];
//reading env and args
void* const new_u45random = arg_buffer[2];
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9329);

//creating new make-kont closure
void** clo9704 = alloc_kont(lam9326_spec, 3);

//setting env list
clo9704[1] = new_u45random;
clo9704[2] = decode_clo_array[1];
clo9704[3] = decode_clo_array[2];
void* f_lam_9166 = encode_clo(clo9704);



//creating new make-kont closure
void** clo9705 = alloc_kont(lam9318_spec, 2);

//setting env list
clo9705[1] = f_lam_9166;
clo9705[2] = new_u45random;
void* f_lam_9167 = encode_clo(clo9705);



//clo-app
length_spec(length, f_lam_9167, decode_clo_array[2]);
}

inline void lam9328_spec(void* env9329, void* new_u45random) // lam9328 
{
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9329);

//creating new make-kont closure
void** clo9706 = alloc_kont(lam9326_spec, 3);

//setting env list
clo9706[1] = new_u45random;
clo9706[2] = decode_clo_array[1];
clo9706[3] = decode_clo_array[2];
void* f_lam_9166 = encode_clo(clo9706);



//creating new make-kont closure
void** clo9707 = alloc_kont(lam9318_spec, 2);

//setting env list
clo9707[1] = f_lam_9166;
clo9707[2] = new_u45random;
void* f_lam_9167 = encode_clo(clo9707);



//clo-app
length_spec(length, f_lam_9167, decode_clo_array[2]);
}

inline void shuffle_u45aux_fptr() // shuffle-aux -> generic version 
{
//reading env and args
void* const kont9162 = arg_buffer[2];
void* const lst = arg_buffer[3];
void* const current_u45random = arg_buffer[4];
//decoding closure array
void** decode_clo_array = nullptr;

//if-clause
if(is_true(apply_prim_null_u63_1(lst)))
{
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(kont9162)[0])(kont9162, apply_prim_list_0());
}
else
{

//creating new make-kont closure
void** clo9708 = alloc_kont(lam9328_spec, 2);

//setting env list
clo9708[1] = kont9162;
clo9708[2] = lst;
void* f_lam_9168 = encode_clo(clo9708);



//clo-app
next_u45random_spec(next_u45random, f_lam_9168, current_u45random);
}

}

inline void shuffle_u45aux_spec(void* _9330, void* kont9162, void* lst, void* current_u45random) // shuffle-aux 
{
//decoding closure array
void** decode_clo_array = nullptr;

//if-clause
if(is_true(apply_prim_null_u63_1(lst)))
{
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(kont9162)[0])(kont9162, apply_prim_list_0());
}
else
{

//creating new make-kont closure
void** clo9709 = alloc_kont(lam9328_spec, 2);

//setting env list
clo9709[1] = kont9162;
clo9709[2] = lst;
void* f_lam_9168 = encode_clo(clo9709);



//clo-app
next_u45random_spec(next_u45random, f_lam_9168, current_u45random);
}

}

inline void lam9331_fptr() // lam9331 -> generic version 
{
//reading env
void* const env9332 = arg_buffer[1];
//reading env and args
void* const id_8884 = arg_buffer[2];
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9332);

//clo-app
shuffle_u45aux_spec(shuffle_u45aux, decode_clo_array[2], decode_clo_array[1], id_8884);
}

inline void lam9331_spec(void* env9332, void* id_8884) // lam9331 
{
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9332);

//clo-app
shuffle_u45aux_spec(shuffle_u45aux, decode_clo_array[2], decode_clo_array[1], id_8884);
}

inline void shuffle_fptr() // shuffle -> generic version 
{
//reading env and args
void* const kont9169 = arg_buffer[2];
void* const lst = arg_buffer[3];
//decoding closure array
void** decode_clo_array = nullptr;

//creating new make-kont closure
void** clo9710 = alloc_kont(lam9331_spec, 2);

//setting env list
clo9710[1] = lst;
clo9710[2] = kont9169;
void* f_lam_9170 = encode_clo(clo9710);



//clo-app
initial_u45random_spec(initial_u45random, f_lam_9170);
}

inline void shuffle_spec(void* _9333, void* kont9169, void* lst) // shuffle 
{
//decoding closure array
void** decode_clo_array = nullptr;

//creating new make-kont closure
void** clo9711 = alloc_kont(lam9331_spec, 2);

//setting env list
clo9711[1] = lst;
clo9711[2] = kont9169;
void* f_lam_9170 = encode_clo(clo9711);



//clo-app
initial_u45random_spec(initial_u45random, f_lam_9170);
}

inline void lam9334_fptr() // lam9334 -> generic version 
{
//reading env
void* const env9335 = arg_buffer[1];
//reading env and args
void* const cont9172 = arg_buffer[2];
void* const x = arg_buffer[3];
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9335);

//if-clause
if(is_true(x))
{
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(cont9172)[0])(cont9172, encode_str(new(GC) std::string("_")));
}
else
{
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(cont9172)[0])(cont9172, encode_str(new(GC) std::string("*")));
}

}

inline void lam9334_spec(void* env9335, void* cont9172, void* x) // lam9334 
{
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9335);

//if-clause
if(is_true(x))
{
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(cont9172)[0])(cont9172, encode_str(new(GC) std::string("_")));
}
else
{
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(cont9172)[0])(cont9172, encode_str(new(GC) std::string("*")));
}

}

inline void cave_u45to_u45maze_fptr() // cave-to-maze -> generic version 
{
//reading env and args
void* const kont9171 = arg_buffer[2];
void* const cave = arg_buffer[3];
//decoding closure array
void** decode_clo_array = nullptr;

//creating new closure instance
void** clo9712 = alloc_clo(lam9334_fptr, 0);
void* id_8887 = encode_clo(clo9712);



//clo-app
matrix_u45map_spec(matrix_u45map, kont9171, id_8887, cave);
}

inline void cave_u45to_u45maze_spec(void* _9336, void* kont9171, void* cave) // cave-to-maze 
{
//decoding closure array
void** decode_clo_array = nullptr;

//creating new closure instance
void** clo9713 = alloc_clo(lam9334_fptr, 0);
void* id_8887 = encode_clo(clo9713);



//clo-app
matrix_u45map_spec(matrix_u45map, kont9171, id_8887, cave);
}

inline void lam9337_fptr() // lam9337 -> generic version 
{
//reading env
void* const env9338 = arg_buffer[1];
//reading env and args
void* const id_8933 = arg_buffer[2];
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9338);

//clo-app
arg_buffer[1] = append;
arg_buffer[2] = decode_clo_array[3];
arg_buffer[3] = decode_clo_array[4];
arg_buffer[4] = decode_clo_array[1];
arg_buffer[5] = decode_clo_array[2];
arg_buffer[6] = id_8933;
numArgs = 6;
append_fptr();
}

inline void lam9337_spec(void* env9338, void* id_8933) // lam9337 
{
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9338);

//clo-app
arg_buffer[1] = append;
arg_buffer[2] = decode_clo_array[3];
arg_buffer[3] = decode_clo_array[4];
arg_buffer[4] = decode_clo_array[1];
arg_buffer[5] = decode_clo_array[2];
arg_buffer[6] = id_8933;
numArgs = 6;
append_fptr();
}

inline void lam9339_fptr() // lam9339 -> generic version 
{
//reading env
void* const env9340 = arg_buffer[1];
//reading env and args
void* const id_8928 = arg_buffer[2];
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9340);

//creating new make-kont closure
void** clo9714 = alloc_kont(lam9337_spec, 4);

//setting env list
clo9714[1] = decode_clo_array[1];
clo9714[2] = decode_clo_array[4];
clo9714[3] = decode_clo_array[5];
clo9714[4] = decode_clo_array[6];
void* f_lam_9174 = encode_clo(clo9714);



//if-clause
if(is_true(id_8928))
{
// kont-clo-app case
lam9337_spec(f_lam_9174, apply_prim_list_1(apply_prim_cons_2(decode_clo_array[2], apply_prim__u43_2(decode_clo_array[3], int9468))));
}
else
{
// kont-clo-app case
lam9337_spec(f_lam_9174, apply_prim_list_0());
}

}

inline void lam9339_spec(void* env9340, void* id_8928) // lam9339 
{
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9340);

//creating new make-kont closure
void** clo9715 = alloc_kont(lam9337_spec, 4);

//setting env list
clo9715[1] = decode_clo_array[1];
clo9715[2] = decode_clo_array[4];
clo9715[3] = decode_clo_array[5];
clo9715[4] = decode_clo_array[6];
void* f_lam_9174 = encode_clo(clo9715);



//if-clause
if(is_true(id_8928))
{
// kont-clo-app case
lam9337_spec(f_lam_9174, apply_prim_list_1(apply_prim_cons_2(decode_clo_array[2], apply_prim__u43_2(decode_clo_array[3], int9468))));
}
else
{
// kont-clo-app case
lam9337_spec(f_lam_9174, apply_prim_list_0());
}

}

inline void lam9341_fptr() // lam9341 -> generic version 
{
//reading env
void* const env9342 = arg_buffer[1];
//reading env and args
void* const id_8921 = arg_buffer[2];
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9342);

//creating new make-kont closure
void** clo9716 = alloc_kont(lam9339_spec, 6);

//setting env list
clo9716[1] = decode_clo_array[3];
clo9716[2] = decode_clo_array[4];
clo9716[3] = decode_clo_array[5];
clo9716[4] = id_8921;
clo9716[5] = decode_clo_array[6];
clo9716[6] = decode_clo_array[7];
void* f_lam_9175 = encode_clo(clo9716);



//if-clause
if(is_true(apply_prim__u60_2(decode_clo_array[5], apply_prim__u45_2(decode_clo_array[1], int9468))))
{

//clo-app
matrix_u45read_spec(matrix_u45read, f_lam_9175, decode_clo_array[2], decode_clo_array[4], apply_prim__u43_2(decode_clo_array[5], int9468));
}
else
{
// kont-clo-app case
lam9339_spec(f_lam_9175, bool_f9473);
}

}

inline void lam9341_spec(void* env9342, void* id_8921) // lam9341 
{
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9342);

//creating new make-kont closure
void** clo9717 = alloc_kont(lam9339_spec, 6);

//setting env list
clo9717[1] = decode_clo_array[3];
clo9717[2] = decode_clo_array[4];
clo9717[3] = decode_clo_array[5];
clo9717[4] = id_8921;
clo9717[5] = decode_clo_array[6];
clo9717[6] = decode_clo_array[7];
void* f_lam_9175 = encode_clo(clo9717);



//if-clause
if(is_true(apply_prim__u60_2(decode_clo_array[5], apply_prim__u45_2(decode_clo_array[1], int9468))))
{

//clo-app
matrix_u45read_spec(matrix_u45read, f_lam_9175, decode_clo_array[2], decode_clo_array[4], apply_prim__u43_2(decode_clo_array[5], int9468));
}
else
{
// kont-clo-app case
lam9339_spec(f_lam_9175, bool_f9473);
}

}

inline void lam9343_fptr() // lam9343 -> generic version 
{
//reading env
void* const env9344 = arg_buffer[1];
//reading env and args
void* const id_8916 = arg_buffer[2];
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9344);

//creating new make-kont closure
void** clo9718 = alloc_kont(lam9341_spec, 7);

//setting env list
clo9718[1] = decode_clo_array[1];
clo9718[2] = decode_clo_array[2];
clo9718[3] = decode_clo_array[3];
clo9718[4] = decode_clo_array[4];
clo9718[5] = decode_clo_array[5];
clo9718[6] = decode_clo_array[6];
clo9718[7] = decode_clo_array[7];
void* f_lam_9176 = encode_clo(clo9718);



//if-clause
if(is_true(id_8916))
{
// kont-clo-app case
lam9341_spec(f_lam_9176, apply_prim_list_1(apply_prim_cons_2(decode_clo_array[4], apply_prim__u45_2(decode_clo_array[5], int9468))));
}
else
{
// kont-clo-app case
lam9341_spec(f_lam_9176, apply_prim_list_0());
}

}

inline void lam9343_spec(void* env9344, void* id_8916) // lam9343 
{
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9344);

//creating new make-kont closure
void** clo9719 = alloc_kont(lam9341_spec, 7);

//setting env list
clo9719[1] = decode_clo_array[1];
clo9719[2] = decode_clo_array[2];
clo9719[3] = decode_clo_array[3];
clo9719[4] = decode_clo_array[4];
clo9719[5] = decode_clo_array[5];
clo9719[6] = decode_clo_array[6];
clo9719[7] = decode_clo_array[7];
void* f_lam_9176 = encode_clo(clo9719);



//if-clause
if(is_true(id_8916))
{
// kont-clo-app case
lam9341_spec(f_lam_9176, apply_prim_list_1(apply_prim_cons_2(decode_clo_array[4], apply_prim__u45_2(decode_clo_array[5], int9468))));
}
else
{
// kont-clo-app case
lam9341_spec(f_lam_9176, apply_prim_list_0());
}

}

inline void lam9345_fptr() // lam9345 -> generic version 
{
//reading env
void* const env9346 = arg_buffer[1];
//reading env and args
void* const id_8910 = arg_buffer[2];
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9346);

//creating new make-kont closure
void** clo9720 = alloc_kont(lam9343_spec, 7);

//setting env list
clo9720[1] = decode_clo_array[1];
clo9720[2] = decode_clo_array[2];
clo9720[3] = id_8910;
clo9720[4] = decode_clo_array[3];
clo9720[5] = decode_clo_array[4];
clo9720[6] = decode_clo_array[5];
clo9720[7] = decode_clo_array[6];
void* f_lam_9177 = encode_clo(clo9720);



//if-clause
if(is_true(apply_prim__u62_2(decode_clo_array[4], int9475)))
{

//clo-app
matrix_u45read_spec(matrix_u45read, f_lam_9177, decode_clo_array[2], decode_clo_array[3], apply_prim__u45_2(decode_clo_array[4], int9468));
}
else
{
// kont-clo-app case
lam9343_spec(f_lam_9177, bool_f9473);
}

}

inline void lam9345_spec(void* env9346, void* id_8910) // lam9345 
{
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9346);

//creating new make-kont closure
void** clo9721 = alloc_kont(lam9343_spec, 7);

//setting env list
clo9721[1] = decode_clo_array[1];
clo9721[2] = decode_clo_array[2];
clo9721[3] = id_8910;
clo9721[4] = decode_clo_array[3];
clo9721[5] = decode_clo_array[4];
clo9721[6] = decode_clo_array[5];
clo9721[7] = decode_clo_array[6];
void* f_lam_9177 = encode_clo(clo9721);



//if-clause
if(is_true(apply_prim__u62_2(decode_clo_array[4], int9475)))
{

//clo-app
matrix_u45read_spec(matrix_u45read, f_lam_9177, decode_clo_array[2], decode_clo_array[3], apply_prim__u45_2(decode_clo_array[4], int9468));
}
else
{
// kont-clo-app case
lam9343_spec(f_lam_9177, bool_f9473);
}

}

inline void lam9347_fptr() // lam9347 -> generic version 
{
//reading env
void* const env9348 = arg_buffer[1];
//reading env and args
void* const id_8905 = arg_buffer[2];
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9348);

//creating new make-kont closure
void** clo9722 = alloc_kont(lam9345_spec, 6);

//setting env list
clo9722[1] = decode_clo_array[1];
clo9722[2] = decode_clo_array[2];
clo9722[3] = decode_clo_array[3];
clo9722[4] = decode_clo_array[4];
clo9722[5] = decode_clo_array[5];
clo9722[6] = decode_clo_array[6];
void* f_lam_9178 = encode_clo(clo9722);



//if-clause
if(is_true(id_8905))
{
// kont-clo-app case
lam9345_spec(f_lam_9178, apply_prim_list_1(apply_prim_cons_2(apply_prim__u43_2(decode_clo_array[3], int9468), decode_clo_array[4])));
}
else
{
// kont-clo-app case
lam9345_spec(f_lam_9178, apply_prim_list_0());
}

}

inline void lam9347_spec(void* env9348, void* id_8905) // lam9347 
{
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9348);

//creating new make-kont closure
void** clo9723 = alloc_kont(lam9345_spec, 6);

//setting env list
clo9723[1] = decode_clo_array[1];
clo9723[2] = decode_clo_array[2];
clo9723[3] = decode_clo_array[3];
clo9723[4] = decode_clo_array[4];
clo9723[5] = decode_clo_array[5];
clo9723[6] = decode_clo_array[6];
void* f_lam_9178 = encode_clo(clo9723);



//if-clause
if(is_true(id_8905))
{
// kont-clo-app case
lam9345_spec(f_lam_9178, apply_prim_list_1(apply_prim_cons_2(apply_prim__u43_2(decode_clo_array[3], int9468), decode_clo_array[4])));
}
else
{
// kont-clo-app case
lam9345_spec(f_lam_9178, apply_prim_list_0());
}

}

inline void lam9349_fptr() // lam9349 -> generic version 
{
//reading env
void* const env9350 = arg_buffer[1];
//reading env and args
void* const id_8898 = arg_buffer[2];
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9350);

//creating new make-kont closure
void** clo9724 = alloc_kont(lam9347_spec, 6);

//setting env list
clo9724[1] = decode_clo_array[1];
clo9724[2] = decode_clo_array[2];
clo9724[3] = decode_clo_array[4];
clo9724[4] = decode_clo_array[5];
clo9724[5] = decode_clo_array[6];
clo9724[6] = id_8898;
void* f_lam_9179 = encode_clo(clo9724);



//if-clause
if(is_true(apply_prim__u60_2(decode_clo_array[4], apply_prim__u45_2(decode_clo_array[3], int9468))))
{

//clo-app
matrix_u45read_spec(matrix_u45read, f_lam_9179, decode_clo_array[2], apply_prim__u43_2(decode_clo_array[4], int9468), decode_clo_array[5]);
}
else
{
// kont-clo-app case
lam9347_spec(f_lam_9179, bool_f9473);
}

}

inline void lam9349_spec(void* env9350, void* id_8898) // lam9349 
{
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9350);

//creating new make-kont closure
void** clo9725 = alloc_kont(lam9347_spec, 6);

//setting env list
clo9725[1] = decode_clo_array[1];
clo9725[2] = decode_clo_array[2];
clo9725[3] = decode_clo_array[4];
clo9725[4] = decode_clo_array[5];
clo9725[5] = decode_clo_array[6];
clo9725[6] = id_8898;
void* f_lam_9179 = encode_clo(clo9725);



//if-clause
if(is_true(apply_prim__u60_2(decode_clo_array[4], apply_prim__u45_2(decode_clo_array[3], int9468))))
{

//clo-app
matrix_u45read_spec(matrix_u45read, f_lam_9179, decode_clo_array[2], apply_prim__u43_2(decode_clo_array[4], int9468), decode_clo_array[5]);
}
else
{
// kont-clo-app case
lam9347_spec(f_lam_9179, bool_f9473);
}

}

inline void lam9351_fptr() // lam9351 -> generic version 
{
//reading env
void* const env9352 = arg_buffer[1];
//reading env and args
void* const id_8893 = arg_buffer[2];
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9352);

//creating new make-kont closure
void** clo9726 = alloc_kont(lam9349_spec, 6);

//setting env list
clo9726[1] = decode_clo_array[1];
clo9726[2] = decode_clo_array[2];
clo9726[3] = decode_clo_array[3];
clo9726[4] = decode_clo_array[4];
clo9726[5] = decode_clo_array[5];
clo9726[6] = decode_clo_array[6];
void* f_lam_9180 = encode_clo(clo9726);



//if-clause
if(is_true(id_8893))
{
// kont-clo-app case
lam9349_spec(f_lam_9180, apply_prim_list_1(apply_prim_cons_2(apply_prim__u45_2(decode_clo_array[4], int9468), decode_clo_array[5])));
}
else
{
// kont-clo-app case
lam9349_spec(f_lam_9180, apply_prim_list_0());
}

}

inline void lam9351_spec(void* env9352, void* id_8893) // lam9351 
{
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9352);

//creating new make-kont closure
void** clo9727 = alloc_kont(lam9349_spec, 6);

//setting env list
clo9727[1] = decode_clo_array[1];
clo9727[2] = decode_clo_array[2];
clo9727[3] = decode_clo_array[3];
clo9727[4] = decode_clo_array[4];
clo9727[5] = decode_clo_array[5];
clo9727[6] = decode_clo_array[6];
void* f_lam_9180 = encode_clo(clo9727);



//if-clause
if(is_true(id_8893))
{
// kont-clo-app case
lam9349_spec(f_lam_9180, apply_prim_list_1(apply_prim_cons_2(apply_prim__u45_2(decode_clo_array[4], int9468), decode_clo_array[5])));
}
else
{
// kont-clo-app case
lam9349_spec(f_lam_9180, apply_prim_list_0());
}

}

inline void lam9353_fptr() // lam9353 -> generic version 
{
//reading env
void* const env9354 = arg_buffer[1];
//reading env and args
void* const size = arg_buffer[2];
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9354);

//creating new make-kont closure
void** clo9728 = alloc_kont(lam9351_spec, 6);

//setting env list
clo9728[1] = apply_prim_cdr_1(size);
clo9728[2] = decode_clo_array[1];
clo9728[3] = apply_prim_car_1(size);
clo9728[4] = apply_prim_car_1(decode_clo_array[2]);
clo9728[5] = apply_prim_cdr_1(decode_clo_array[2]);
clo9728[6] = decode_clo_array[3];
void* f_lam_9181 = encode_clo(clo9728);



//if-clause
if(is_true(apply_prim__u62_2(apply_prim_car_1(decode_clo_array[2]), int9475)))
{

//clo-app
matrix_u45read_spec(matrix_u45read, f_lam_9181, decode_clo_array[1], apply_prim__u45_2(apply_prim_car_1(decode_clo_array[2]), int9468), apply_prim_cdr_1(decode_clo_array[2]));
}
else
{
// kont-clo-app case
lam9351_spec(f_lam_9181, bool_f9473);
}

}

inline void lam9353_spec(void* env9354, void* size) // lam9353 
{
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9354);

//creating new make-kont closure
void** clo9729 = alloc_kont(lam9351_spec, 6);

//setting env list
clo9729[1] = apply_prim_cdr_1(size);
clo9729[2] = decode_clo_array[1];
clo9729[3] = apply_prim_car_1(size);
clo9729[4] = apply_prim_car_1(decode_clo_array[2]);
clo9729[5] = apply_prim_cdr_1(decode_clo_array[2]);
clo9729[6] = decode_clo_array[3];
void* f_lam_9181 = encode_clo(clo9729);



//if-clause
if(is_true(apply_prim__u62_2(apply_prim_car_1(decode_clo_array[2]), int9475)))
{

//clo-app
matrix_u45read_spec(matrix_u45read, f_lam_9181, decode_clo_array[1], apply_prim__u45_2(apply_prim_car_1(decode_clo_array[2]), int9468), apply_prim_cdr_1(decode_clo_array[2]));
}
else
{
// kont-clo-app case
lam9351_spec(f_lam_9181, bool_f9473);
}

}

inline void neighboring_u45cavities_fptr() // neighboring-cavities -> generic version 
{
//reading env and args
void* const kont9173 = arg_buffer[2];
void* const pos = arg_buffer[3];
void* const cave = arg_buffer[4];
//decoding closure array
void** decode_clo_array = nullptr;

//creating new make-kont closure
void** clo9730 = alloc_kont(lam9353_spec, 3);

//setting env list
clo9730[1] = cave;
clo9730[2] = pos;
clo9730[3] = kont9173;
void* f_lam_9182 = encode_clo(clo9730);



//clo-app
matrix_u45size_spec(matrix_u45size, f_lam_9182, cave);
}

inline void neighboring_u45cavities_spec(void* _9355, void* kont9173, void* pos, void* cave) // neighboring-cavities 
{
//decoding closure array
void** decode_clo_array = nullptr;

//creating new make-kont closure
void** clo9731 = alloc_kont(lam9353_spec, 3);

//setting env list
clo9731[1] = cave;
clo9731[2] = pos;
clo9731[3] = kont9173;
void* f_lam_9182 = encode_clo(clo9731);



//clo-app
matrix_u45size_spec(matrix_u45size, f_lam_9182, cave);
}

inline void lam9356_fptr() // lam9356 -> generic version 
{
//reading env
void* const env9357 = arg_buffer[1];
//reading env and args
void* const id_8937 = arg_buffer[2];
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9357);

//clo-app
my_u45foldl_spec(my_u45foldl, decode_clo_array[1], decode_clo_array[3], decode_clo_array[2], id_8937);
}

inline void lam9356_spec(void* env9357, void* id_8937) // lam9356 
{
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9357);

//clo-app
my_u45foldl_spec(my_u45foldl, decode_clo_array[1], decode_clo_array[3], decode_clo_array[2], id_8937);
}

inline void lam9358_fptr() // lam9358 -> generic version 
{
//reading env
void* const env9359 = arg_buffer[1];
//reading env and args
void* const id_8936 = arg_buffer[2];
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9359);

//creating new make-kont closure
void** clo9732 = alloc_kont(lam9356_spec, 3);

//setting env list
clo9732[1] = decode_clo_array[2];
clo9732[2] = id_8936;
clo9732[3] = decode_clo_array[4];
void* f_lam_9185 = encode_clo(clo9732);



//clo-app
neighboring_u45cavities_spec(neighboring_u45cavities, f_lam_9185, decode_clo_array[3], decode_clo_array[1]);
}

inline void lam9358_spec(void* env9359, void* id_8936) // lam9358 
{
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9359);

//creating new make-kont closure
void** clo9733 = alloc_kont(lam9356_spec, 3);

//setting env list
clo9733[1] = decode_clo_array[2];
clo9733[2] = id_8936;
clo9733[3] = decode_clo_array[4];
void* f_lam_9185 = encode_clo(clo9733);



//clo-app
neighboring_u45cavities_spec(neighboring_u45cavities, f_lam_9185, decode_clo_array[3], decode_clo_array[1]);
}

inline void lam9360_fptr() // lam9360 -> generic version 
{
//reading env
void* const env9361 = arg_buffer[1];
//reading env and args
void* const cont9184 = arg_buffer[2];
void* const c = arg_buffer[3];
void* const nc = arg_buffer[4];
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9361);

//clo-app
change_u45cavity_u45aux_spec(change_u45cavity_u45aux, cont9184, c, nc, decode_clo_array[2], decode_clo_array[1]);
}

inline void lam9360_spec(void* env9361, void* cont9184, void* c, void* nc) // lam9360 
{
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9361);

//clo-app
change_u45cavity_u45aux_spec(change_u45cavity_u45aux, cont9184, c, nc, decode_clo_array[2], decode_clo_array[1]);
}

inline void lam9362_fptr() // lam9362 -> generic version 
{
//reading env
void* const env9363 = arg_buffer[1];
//reading env and args
void* const cavity_u45id = arg_buffer[2];
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9363);

//if-clause
if(is_true(apply_prim_equal_u63_2(cavity_u45id, decode_clo_array[6])))
{

//creating new closure instance
void** clo9734 = alloc_clo(lam9360_fptr, 2);

//setting env list
clo9734[1] = decode_clo_array[6];
clo9734[2] = decode_clo_array[7];
void* id_8935 = encode_clo(clo9734);



//creating new make-kont closure
void** clo9735 = alloc_kont(lam9358_spec, 4);

//setting env list
clo9735[1] = decode_clo_array[1];
clo9735[2] = decode_clo_array[2];
clo9735[3] = decode_clo_array[4];
clo9735[4] = id_8935;
void* f_lam_9186 = encode_clo(clo9735);



//clo-app
matrix_u45write_spec(matrix_u45write, f_lam_9186, decode_clo_array[1], decode_clo_array[3], decode_clo_array[5], decode_clo_array[7]);
}
else
{
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(decode_clo_array[2])[0])(decode_clo_array[2], decode_clo_array[1]);
}

}

inline void lam9362_spec(void* env9363, void* cavity_u45id) // lam9362 
{
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9363);

//if-clause
if(is_true(apply_prim_equal_u63_2(cavity_u45id, decode_clo_array[6])))
{

//creating new closure instance
void** clo9736 = alloc_clo(lam9360_fptr, 2);

//setting env list
clo9736[1] = decode_clo_array[6];
clo9736[2] = decode_clo_array[7];
void* id_8935 = encode_clo(clo9736);



//creating new make-kont closure
void** clo9737 = alloc_kont(lam9358_spec, 4);

//setting env list
clo9737[1] = decode_clo_array[1];
clo9737[2] = decode_clo_array[2];
clo9737[3] = decode_clo_array[4];
clo9737[4] = id_8935;
void* f_lam_9186 = encode_clo(clo9737);



//clo-app
matrix_u45write_spec(matrix_u45write, f_lam_9186, decode_clo_array[1], decode_clo_array[3], decode_clo_array[5], decode_clo_array[7]);
}
else
{
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(decode_clo_array[2])[0])(decode_clo_array[2], decode_clo_array[1]);
}

}

inline void change_u45cavity_u45aux_fptr() // change-cavity-aux -> generic version 
{
//reading env and args
void* const kont9183 = arg_buffer[2];
void* const cave = arg_buffer[3];
void* const pos = arg_buffer[4];
void* const new_u45cavity_u45id = arg_buffer[5];
void* const old_u45cavity_u45id = arg_buffer[6];
//decoding closure array
void** decode_clo_array = nullptr;

//creating new make-kont closure
void** clo9738 = alloc_kont(lam9362_spec, 7);

//setting env list
clo9738[1] = cave;
clo9738[2] = kont9183;
clo9738[3] = apply_prim_car_1(pos);
clo9738[4] = pos;
clo9738[5] = apply_prim_cdr_1(pos);
clo9738[6] = old_u45cavity_u45id;
clo9738[7] = new_u45cavity_u45id;
void* f_lam_9187 = encode_clo(clo9738);



//clo-app
matrix_u45read_spec(matrix_u45read, f_lam_9187, cave, apply_prim_car_1(pos), apply_prim_cdr_1(pos));
}

inline void change_u45cavity_u45aux_spec(void* _9364, void* kont9183, void* cave, void* pos, void* new_u45cavity_u45id, void* old_u45cavity_u45id) // change-cavity-aux 
{
//decoding closure array
void** decode_clo_array = nullptr;

//creating new make-kont closure
void** clo9739 = alloc_kont(lam9362_spec, 7);

//setting env list
clo9739[1] = cave;
clo9739[2] = kont9183;
clo9739[3] = apply_prim_car_1(pos);
clo9739[4] = pos;
clo9739[5] = apply_prim_cdr_1(pos);
clo9739[6] = old_u45cavity_u45id;
clo9739[7] = new_u45cavity_u45id;
void* f_lam_9187 = encode_clo(clo9739);



//clo-app
matrix_u45read_spec(matrix_u45read, f_lam_9187, cave, apply_prim_car_1(pos), apply_prim_cdr_1(pos));
}

inline void lam9365_fptr() // lam9365 -> generic version 
{
//reading env
void* const env9366 = arg_buffer[1];
//reading env and args
void* const id_8938 = arg_buffer[2];
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9366);

//clo-app
change_u45cavity_u45aux_spec(change_u45cavity_u45aux, decode_clo_array[3], decode_clo_array[1], decode_clo_array[2], decode_clo_array[4], id_8938);
}

inline void lam9365_spec(void* env9366, void* id_8938) // lam9365 
{
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9366);

//clo-app
change_u45cavity_u45aux_spec(change_u45cavity_u45aux, decode_clo_array[3], decode_clo_array[1], decode_clo_array[2], decode_clo_array[4], id_8938);
}

inline void change_u45cavity_fptr() // change-cavity -> generic version 
{
//reading env and args
void* const kont9188 = arg_buffer[2];
void* const cave = arg_buffer[3];
void* const pos = arg_buffer[4];
void* const new_u45cavity_u45id = arg_buffer[5];
//decoding closure array
void** decode_clo_array = nullptr;

//creating new make-kont closure
void** clo9740 = alloc_kont(lam9365_spec, 4);

//setting env list
clo9740[1] = cave;
clo9740[2] = pos;
clo9740[3] = kont9188;
clo9740[4] = new_u45cavity_u45id;
void* f_lam_9189 = encode_clo(clo9740);



//clo-app
matrix_u45read_spec(matrix_u45read, f_lam_9189, cave, apply_prim_car_1(pos), apply_prim_cdr_1(pos));
}

inline void change_u45cavity_spec(void* _9367, void* kont9188, void* cave, void* pos, void* new_u45cavity_u45id) // change-cavity 
{
//decoding closure array
void** decode_clo_array = nullptr;

//creating new make-kont closure
void** clo9741 = alloc_kont(lam9365_spec, 4);

//setting env list
clo9741[1] = cave;
clo9741[2] = pos;
clo9741[3] = kont9188;
clo9741[4] = new_u45cavity_u45id;
void* f_lam_9189 = encode_clo(clo9741);



//clo-app
matrix_u45read_spec(matrix_u45read, f_lam_9189, cave, apply_prim_car_1(pos), apply_prim_cdr_1(pos));
}

inline void pierce_fptr() // pierce -> generic version 
{
//reading env and args
void* const kont9190 = arg_buffer[2];
void* const pos = arg_buffer[3];
void* const cave = arg_buffer[4];
//decoding closure array
void** decode_clo_array = nullptr;

//clo-app
matrix_u45write_spec(matrix_u45write, kont9190, cave, apply_prim_car_1(pos), apply_prim_cdr_1(pos), pos);
}

inline void pierce_spec(void* _9368, void* kont9190, void* pos, void* cave) // pierce 
{
//decoding closure array
void** decode_clo_array = nullptr;

//clo-app
matrix_u45write_spec(matrix_u45write, kont9190, cave, apply_prim_car_1(pos), apply_prim_cdr_1(pos), pos);
}

inline void lam9369_fptr() // lam9369 -> generic version 
{
//reading env
void* const env9370 = arg_buffer[1];
//reading env and args
void* const id_8945 = arg_buffer[2];
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9370);

//clo-app
pierce_spec(pierce, decode_clo_array[2], decode_clo_array[1], id_8945);
}

inline void lam9369_spec(void* env9370, void* id_8945) // lam9369 
{
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9370);

//clo-app
pierce_spec(pierce, decode_clo_array[2], decode_clo_array[1], id_8945);
}

inline void lam9371_fptr() // lam9371 -> generic version 
{
//reading env
void* const env9372 = arg_buffer[1];
//reading env and args
void* const cont9193 = arg_buffer[2];
void* const c = arg_buffer[3];
void* const nc = arg_buffer[4];
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9372);

//clo-app
change_u45cavity_spec(change_u45cavity, cont9193, c, nc, decode_clo_array[1]);
}

inline void lam9371_spec(void* env9372, void* cont9193, void* c, void* nc) // lam9371 
{
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9372);

//clo-app
change_u45cavity_spec(change_u45cavity, cont9193, c, nc, decode_clo_array[1]);
}

inline void lam9373_fptr() // lam9373 -> generic version 
{
//reading env
void* const env9374 = arg_buffer[1];
//reading env and args
void* const id_8943 = arg_buffer[2];
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9374);

//if-clause
if(is_true(id_8943))
{
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(decode_clo_array[4])[0])(decode_clo_array[4], decode_clo_array[1]);
}
else
{

//creating new closure instance
void** clo9742 = alloc_clo(lam9371_fptr, 1);

//setting env list
clo9742[1] = decode_clo_array[2];
void* id_8944 = encode_clo(clo9742);



//creating new make-kont closure
void** clo9743 = alloc_kont(lam9369_spec, 2);

//setting env list
clo9743[1] = decode_clo_array[2];
clo9743[2] = decode_clo_array[4];
void* f_lam_9194 = encode_clo(clo9743);



//clo-app
my_u45foldl_spec(my_u45foldl, f_lam_9194, id_8944, decode_clo_array[1], decode_clo_array[3]);
}

}

inline void lam9373_spec(void* env9374, void* id_8943) // lam9373 
{
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9374);

//if-clause
if(is_true(id_8943))
{
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(decode_clo_array[4])[0])(decode_clo_array[4], decode_clo_array[1]);
}
else
{

//creating new closure instance
void** clo9744 = alloc_clo(lam9371_fptr, 1);

//setting env list
clo9744[1] = decode_clo_array[2];
void* id_8944 = encode_clo(clo9744);



//creating new make-kont closure
void** clo9745 = alloc_kont(lam9369_spec, 2);

//setting env list
clo9745[1] = decode_clo_array[2];
clo9745[2] = decode_clo_array[4];
void* f_lam_9194 = encode_clo(clo9745);



//clo-app
my_u45foldl_spec(my_u45foldl, f_lam_9194, id_8944, decode_clo_array[1], decode_clo_array[3]);
}

}

inline void lam9375_fptr() // lam9375 -> generic version 
{
//reading env
void* const env9376 = arg_buffer[1];
//reading env and args
void* const id_8942 = arg_buffer[2];
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9376);

//creating new make-kont closure
void** clo9746 = alloc_kont(lam9373_spec, 4);

//setting env list
clo9746[1] = decode_clo_array[1];
clo9746[2] = decode_clo_array[2];
clo9746[3] = decode_clo_array[3];
clo9746[4] = decode_clo_array[4];
void* f_lam_9195 = encode_clo(clo9746);



//clo-app
duplicates_u63_spec(duplicates_u63, f_lam_9195, id_8942);
}

inline void lam9375_spec(void* env9376, void* id_8942) // lam9375 
{
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9376);

//creating new make-kont closure
void** clo9747 = alloc_kont(lam9373_spec, 4);

//setting env list
clo9747[1] = decode_clo_array[1];
clo9747[2] = decode_clo_array[2];
clo9747[3] = decode_clo_array[3];
clo9747[4] = decode_clo_array[4];
void* f_lam_9195 = encode_clo(clo9747);



//clo-app
duplicates_u63_spec(duplicates_u63, f_lam_9195, id_8942);
}

inline void lam9377_fptr() // lam9377 -> generic version 
{
//reading env
void* const env9378 = arg_buffer[1];
//reading env and args
void* const cont9192 = arg_buffer[2];
void* const nc = arg_buffer[3];
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9378);

//clo-app
matrix_u45read_spec(matrix_u45read, cont9192, decode_clo_array[1], apply_prim_car_1(nc), apply_prim_cdr_1(nc));
}

inline void lam9377_spec(void* env9378, void* cont9192, void* nc) // lam9377 
{
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9378);

//clo-app
matrix_u45read_spec(matrix_u45read, cont9192, decode_clo_array[1], apply_prim_car_1(nc), apply_prim_cdr_1(nc));
}

inline void lam9379_fptr() // lam9379 -> generic version 
{
//reading env
void* const env9380 = arg_buffer[1];
//reading env and args
void* const ncs = arg_buffer[2];
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9380);

//creating new closure instance
void** clo9748 = alloc_clo(lam9377_fptr, 1);

//setting env list
clo9748[1] = decode_clo_array[1];
void* id_8941 = encode_clo(clo9748);



//creating new make-kont closure
void** clo9749 = alloc_kont(lam9375_spec, 4);

//setting env list
clo9749[1] = decode_clo_array[1];
clo9749[2] = decode_clo_array[2];
clo9749[3] = ncs;
clo9749[4] = decode_clo_array[3];
void* f_lam_9196 = encode_clo(clo9749);



//clo-app
map_spec(map, f_lam_9196, id_8941, ncs);
}

inline void lam9379_spec(void* env9380, void* ncs) // lam9379 
{
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9380);

//creating new closure instance
void** clo9750 = alloc_clo(lam9377_fptr, 1);

//setting env list
clo9750[1] = decode_clo_array[1];
void* id_8941 = encode_clo(clo9750);



//creating new make-kont closure
void** clo9751 = alloc_kont(lam9375_spec, 4);

//setting env list
clo9751[1] = decode_clo_array[1];
clo9751[2] = decode_clo_array[2];
clo9751[3] = ncs;
clo9751[4] = decode_clo_array[3];
void* f_lam_9196 = encode_clo(clo9751);



//clo-app
map_spec(map, f_lam_9196, id_8941, ncs);
}

inline void try_u45to_u45pierce_fptr() // try-to-pierce -> generic version 
{
//reading env and args
void* const kont9191 = arg_buffer[2];
void* const pos = arg_buffer[3];
void* const cave = arg_buffer[4];
//decoding closure array
void** decode_clo_array = nullptr;

//creating new make-kont closure
void** clo9752 = alloc_kont(lam9379_spec, 3);

//setting env list
clo9752[1] = cave;
clo9752[2] = pos;
clo9752[3] = kont9191;
void* f_lam_9197 = encode_clo(clo9752);



//clo-app
neighboring_u45cavities_spec(neighboring_u45cavities, f_lam_9197, pos, cave);
}

inline void try_u45to_u45pierce_spec(void* _9381, void* kont9191, void* pos, void* cave) // try-to-pierce 
{
//decoding closure array
void** decode_clo_array = nullptr;

//creating new make-kont closure
void** clo9753 = alloc_kont(lam9379_spec, 3);

//setting env list
clo9753[1] = cave;
clo9753[2] = pos;
clo9753[3] = kont9191;
void* f_lam_9197 = encode_clo(clo9753);



//clo-app
neighboring_u45cavities_spec(neighboring_u45cavities, f_lam_9197, pos, cave);
}

inline void lam9382_fptr() // lam9382 -> generic version 
{
//reading env
void* const env9383 = arg_buffer[1];
//reading env and args
void* const id_8948 = arg_buffer[2];
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9383);

//clo-app
pierce_u45randomly_spec(pierce_u45randomly, decode_clo_array[1], decode_clo_array[2], id_8948);
}

inline void lam9382_spec(void* env9383, void* id_8948) // lam9382 
{
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9383);

//clo-app
pierce_u45randomly_spec(pierce_u45randomly, decode_clo_array[1], decode_clo_array[2], id_8948);
}

inline void pierce_u45randomly_fptr() // pierce-randomly -> generic version 
{
//reading env and args
void* const kont9198 = arg_buffer[2];
void* const possible_u45holes = arg_buffer[3];
void* const cave = arg_buffer[4];
//decoding closure array
void** decode_clo_array = nullptr;

//if-clause
if(is_true(apply_prim_null_u63_1(possible_u45holes)))
{
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(kont9198)[0])(kont9198, cave);
}
else
{

//creating new make-kont closure
void** clo9754 = alloc_kont(lam9382_spec, 2);

//setting env list
clo9754[1] = kont9198;
clo9754[2] = apply_prim_cdr_1(possible_u45holes);
void* f_lam_9199 = encode_clo(clo9754);



//clo-app
try_u45to_u45pierce_spec(try_u45to_u45pierce, f_lam_9199, apply_prim_car_1(possible_u45holes), cave);
}

}

inline void pierce_u45randomly_spec(void* _9384, void* kont9198, void* possible_u45holes, void* cave) // pierce-randomly 
{
//decoding closure array
void** decode_clo_array = nullptr;

//if-clause
if(is_true(apply_prim_null_u63_1(possible_u45holes)))
{
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(kont9198)[0])(kont9198, cave);
}
else
{

//creating new make-kont closure
void** clo9755 = alloc_kont(lam9382_spec, 2);

//setting env list
clo9755[1] = kont9198;
clo9755[2] = apply_prim_cdr_1(possible_u45holes);
void* f_lam_9199 = encode_clo(clo9755);



//clo-app
try_u45to_u45pierce_spec(try_u45to_u45pierce, f_lam_9199, apply_prim_car_1(possible_u45holes), cave);
}

}

inline void lam9385_fptr() // lam9385 -> generic version 
{
//reading env
void* const env9386 = arg_buffer[1];
//reading env and args
void* const xy8950 = arg_buffer[2];
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9386);
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(decode_clo_array[1])[0])(decode_clo_array[1], xy8950);
}

inline void lam9385_spec(void* env9386, void* xy8950) // lam9385 
{
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9386);
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(decode_clo_array[1])[0])(decode_clo_array[1], xy8950);
}

inline void lam9387_fptr() // lam9387 -> generic version 
{
//reading env
void* const env9388 = arg_buffer[1];
//reading env and args
void* const xy8958 = arg_buffer[2];
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9388);
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(decode_clo_array[1])[0])(decode_clo_array[1], xy8958);
}

inline void lam9387_spec(void* env9388, void* xy8958) // lam9387 
{
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9388);
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(decode_clo_array[1])[0])(decode_clo_array[1], xy8958);
}

inline void lam9389_fptr() // lam9389 -> generic version 
{
//reading env
void* const env9390 = arg_buffer[1];
//reading env and args
void* const id_8960 = arg_buffer[2];
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9390);

//if-clause
if(is_true(id_8960))
{
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(decode_clo_array[1])[0])(decode_clo_array[1], apply_prim_cons_2(decode_clo_array[2], decode_clo_array[3]));
}
else
{
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(decode_clo_array[1])[0])(decode_clo_array[1], bool_f9473);
}

}

inline void lam9389_spec(void* env9390, void* id_8960) // lam9389 
{
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9390);

//if-clause
if(is_true(id_8960))
{
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(decode_clo_array[1])[0])(decode_clo_array[1], apply_prim_cons_2(decode_clo_array[2], decode_clo_array[3]));
}
else
{
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(decode_clo_array[1])[0])(decode_clo_array[1], bool_f9473);
}

}

inline void lam9391_fptr() // lam9391 -> generic version 
{
//reading env
void* const env9392 = arg_buffer[1];
//reading env and args
void* const id_8957 = arg_buffer[2];
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9392);

//creating new make-kont closure
void** clo9756 = alloc_kont(lam9389_spec, 3);

//setting env list
clo9756[1] = decode_clo_array[1];
clo9756[2] = decode_clo_array[2];
clo9756[3] = decode_clo_array[3];
void* f_lam_9212 = encode_clo(clo9756);



//if-clause
if(is_true(id_8957))
{

//creating new make-kont closure
void** clo9757 = alloc_kont(lam9387_spec, 1);

//setting env list
clo9757[1] = f_lam_9212;
void* f_lam_9213 = encode_clo(clo9757);



//clo-app
even_u63_spec(even_u63, f_lam_9213, decode_clo_array[3]);
}
else
{
// kont-clo-app case
lam9389_spec(f_lam_9212, bool_f9473);
}

}

inline void lam9391_spec(void* env9392, void* id_8957) // lam9391 
{
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9392);

//creating new make-kont closure
void** clo9758 = alloc_kont(lam9389_spec, 3);

//setting env list
clo9758[1] = decode_clo_array[1];
clo9758[2] = decode_clo_array[2];
clo9758[3] = decode_clo_array[3];
void* f_lam_9212 = encode_clo(clo9758);



//if-clause
if(is_true(id_8957))
{

//creating new make-kont closure
void** clo9759 = alloc_kont(lam9387_spec, 1);

//setting env list
clo9759[1] = f_lam_9212;
void* f_lam_9213 = encode_clo(clo9759);



//clo-app
even_u63_spec(even_u63, f_lam_9213, decode_clo_array[3]);
}
else
{
// kont-clo-app case
lam9389_spec(f_lam_9212, bool_f9473);
}

}

inline void lam9393_fptr() // lam9393 -> generic version 
{
//reading env
void* const env9394 = arg_buffer[1];
//reading env and args
void* const cont9211 = arg_buffer[2];
void* const i = arg_buffer[3];
void* const j = arg_buffer[4];
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9394);

//creating new make-kont closure
void** clo9760 = alloc_kont(lam9391_spec, 3);

//setting env list
clo9760[1] = cont9211;
clo9760[2] = i;
clo9760[3] = j;
void* f_lam_9214 = encode_clo(clo9760);



//clo-app
even_u63_spec(even_u63, f_lam_9214, i);
}

inline void lam9393_spec(void* env9394, void* cont9211, void* i, void* j) // lam9393 
{
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9394);

//creating new make-kont closure
void** clo9761 = alloc_kont(lam9391_spec, 3);

//setting env list
clo9761[1] = cont9211;
clo9761[2] = i;
clo9761[3] = j;
void* f_lam_9214 = encode_clo(clo9761);



//clo-app
even_u63_spec(even_u63, f_lam_9214, i);
}

inline void lam9395_fptr() // lam9395 -> generic version 
{
//reading env
void* const env9396 = arg_buffer[1];
//reading env and args
void* const id_8974 = arg_buffer[2];
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9396);

//clo-app
concat_spec(concat, decode_clo_array[1], id_8974);
}

inline void lam9395_spec(void* env9396, void* id_8974) // lam9395 
{
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9396);

//clo-app
concat_spec(concat, decode_clo_array[1], id_8974);
}

inline void lam9397_fptr() // lam9397 -> generic version 
{
//reading env
void* const env9398 = arg_buffer[1];
//reading env and args
void* const id_8972 = arg_buffer[2];
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9398);

//clo-app
concat_spec(concat, decode_clo_array[1], id_8972);
}

inline void lam9397_spec(void* env9398, void* id_8972) // lam9397 
{
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9398);

//clo-app
concat_spec(concat, decode_clo_array[1], id_8972);
}

inline void lam9399_fptr() // lam9399 -> generic version 
{
//reading env
void* const env9400 = arg_buffer[1];
//reading env and args
void* const id_8967 = arg_buffer[2];
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9400);

//if-clause
if(is_true(apply_prim_equal_u63_2(decode_clo_array[3], id_8967)))
{
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(decode_clo_array[4])[0])(decode_clo_array[4], apply_prim_list_0());
}
else
{
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(decode_clo_array[4])[0])(decode_clo_array[4], apply_prim_list_1(apply_prim_cons_2(decode_clo_array[1], decode_clo_array[2])));
}

}

inline void lam9399_spec(void* env9400, void* id_8967) // lam9399 
{
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9400);

//if-clause
if(is_true(apply_prim_equal_u63_2(decode_clo_array[3], id_8967)))
{
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(decode_clo_array[4])[0])(decode_clo_array[4], apply_prim_list_0());
}
else
{
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(decode_clo_array[4])[0])(decode_clo_array[4], apply_prim_list_1(apply_prim_cons_2(decode_clo_array[1], decode_clo_array[2])));
}

}

inline void lam9401_fptr() // lam9401 -> generic version 
{
//reading env
void* const env9402 = arg_buffer[1];
//reading env and args
void* const id_8966 = arg_buffer[2];
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9402);

//creating new make-kont closure
void** clo9762 = alloc_kont(lam9399_spec, 4);

//setting env list
clo9762[1] = decode_clo_array[1];
clo9762[2] = decode_clo_array[2];
clo9762[3] = id_8966;
clo9762[4] = decode_clo_array[3];
void* f_lam_9206 = encode_clo(clo9762);



//clo-app
even_u63_spec(even_u63, f_lam_9206, decode_clo_array[2]);
}

inline void lam9401_spec(void* env9402, void* id_8966) // lam9401 
{
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9402);

//creating new make-kont closure
void** clo9763 = alloc_kont(lam9399_spec, 4);

//setting env list
clo9763[1] = decode_clo_array[1];
clo9763[2] = decode_clo_array[2];
clo9763[3] = id_8966;
clo9763[4] = decode_clo_array[3];
void* f_lam_9206 = encode_clo(clo9763);



//clo-app
even_u63_spec(even_u63, f_lam_9206, decode_clo_array[2]);
}

inline void lam9403_fptr() // lam9403 -> generic version 
{
//reading env
void* const env9404 = arg_buffer[1];
//reading env and args
void* const cont9205 = arg_buffer[2];
void* const j = arg_buffer[3];
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9404);

//creating new make-kont closure
void** clo9764 = alloc_kont(lam9401_spec, 3);

//setting env list
clo9764[1] = decode_clo_array[1];
clo9764[2] = j;
clo9764[3] = cont9205;
void* f_lam_9207 = encode_clo(clo9764);



//clo-app
even_u63_spec(even_u63, f_lam_9207, decode_clo_array[1]);
}

inline void lam9403_spec(void* env9404, void* cont9205, void* j) // lam9403 
{
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9404);

//creating new make-kont closure
void** clo9765 = alloc_kont(lam9401_spec, 3);

//setting env list
clo9765[1] = decode_clo_array[1];
clo9765[2] = j;
clo9765[3] = cont9205;
void* f_lam_9207 = encode_clo(clo9765);



//clo-app
even_u63_spec(even_u63, f_lam_9207, decode_clo_array[1]);
}

inline void lam9405_fptr() // lam9405 -> generic version 
{
//reading env
void* const env9406 = arg_buffer[1];
//reading env and args
void* const cont9204 = arg_buffer[2];
void* const i = arg_buffer[3];
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9406);

//creating new closure instance
void** clo9766 = alloc_clo(lam9403_fptr, 1);

//setting env list
clo9766[1] = i;
void* id_8971 = encode_clo(clo9766);



//creating new make-kont closure
void** clo9767 = alloc_kont(lam9397_spec, 1);

//setting env list
clo9767[1] = cont9204;
void* f_lam_9208 = encode_clo(clo9767);



//clo-app
my_u45for_spec(my_u45for, f_lam_9208, int9475, decode_clo_array[1], id_8971);
}

inline void lam9405_spec(void* env9406, void* cont9204, void* i) // lam9405 
{
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9406);

//creating new closure instance
void** clo9768 = alloc_clo(lam9403_fptr, 1);

//setting env list
clo9768[1] = i;
void* id_8971 = encode_clo(clo9768);



//creating new make-kont closure
void** clo9769 = alloc_kont(lam9397_spec, 1);

//setting env list
clo9769[1] = cont9204;
void* f_lam_9208 = encode_clo(clo9769);



//clo-app
my_u45for_spec(my_u45for, f_lam_9208, int9475, decode_clo_array[1], id_8971);
}

inline void lam9407_fptr() // lam9407 -> generic version 
{
//reading env
void* const env9408 = arg_buffer[1];
//reading env and args
void* const id_8976 = arg_buffer[2];
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9408);

//clo-app
cave_u45to_u45maze_spec(cave_u45to_u45maze, decode_clo_array[1], id_8976);
}

inline void lam9407_spec(void* env9408, void* id_8976) // lam9407 
{
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9408);

//clo-app
cave_u45to_u45maze_spec(cave_u45to_u45maze, decode_clo_array[1], id_8976);
}

inline void lam9409_fptr() // lam9409 -> generic version 
{
//reading env
void* const env9410 = arg_buffer[1];
//reading env and args
void* const id_8975 = arg_buffer[2];
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9410);

//creating new make-kont closure
void** clo9770 = alloc_kont(lam9407_spec, 1);

//setting env list
clo9770[1] = decode_clo_array[1];
void* f_lam_9201 = encode_clo(clo9770);



//clo-app
pierce_u45randomly_spec(pierce_u45randomly, f_lam_9201, id_8975, decode_clo_array[2]);
}

inline void lam9409_spec(void* env9410, void* id_8975) // lam9409 
{
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9410);

//creating new make-kont closure
void** clo9771 = alloc_kont(lam9407_spec, 1);

//setting env list
clo9771[1] = decode_clo_array[1];
void* f_lam_9201 = encode_clo(clo9771);



//clo-app
pierce_u45randomly_spec(pierce_u45randomly, f_lam_9201, id_8975, decode_clo_array[2]);
}

inline void lam9411_fptr() // lam9411 -> generic version 
{
//reading env
void* const env9412 = arg_buffer[1];
//reading env and args
void* const possible_u45holes = arg_buffer[2];
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9412);

//creating new make-kont closure
void** clo9772 = alloc_kont(lam9409_spec, 2);

//setting env list
clo9772[1] = decode_clo_array[1];
clo9772[2] = decode_clo_array[2];
void* f_lam_9202 = encode_clo(clo9772);



//clo-app
shuffle_spec(shuffle, f_lam_9202, possible_u45holes);
}

inline void lam9411_spec(void* env9412, void* possible_u45holes) // lam9411 
{
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9412);

//creating new make-kont closure
void** clo9773 = alloc_kont(lam9409_spec, 2);

//setting env list
clo9773[1] = decode_clo_array[1];
clo9773[2] = decode_clo_array[2];
void* f_lam_9202 = encode_clo(clo9773);



//clo-app
shuffle_spec(shuffle, f_lam_9202, possible_u45holes);
}

inline void lam9413_fptr() // lam9413 -> generic version 
{
//reading env
void* const env9414 = arg_buffer[1];
//reading env and args
void* const cave = arg_buffer[2];
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9414);

//creating new make-kont closure
void** clo9774 = alloc_kont(lam9411_spec, 2);

//setting env list
clo9774[1] = decode_clo_array[1];
clo9774[2] = cave;
void* f_lam_9203 = encode_clo(clo9774);



//creating new closure instance
void** clo9775 = alloc_clo(lam9405_fptr, 1);

//setting env list
clo9775[1] = decode_clo_array[2];
void* id_8973 = encode_clo(clo9775);



//creating new make-kont closure
void** clo9776 = alloc_kont(lam9395_spec, 1);

//setting env list
clo9776[1] = f_lam_9203;
void* f_lam_9209 = encode_clo(clo9776);



//clo-app
my_u45for_spec(my_u45for, f_lam_9209, int9475, decode_clo_array[3], id_8973);
}

inline void lam9413_spec(void* env9414, void* cave) // lam9413 
{
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9414);

//creating new make-kont closure
void** clo9777 = alloc_kont(lam9411_spec, 2);

//setting env list
clo9777[1] = decode_clo_array[1];
clo9777[2] = cave;
void* f_lam_9203 = encode_clo(clo9777);



//creating new closure instance
void** clo9778 = alloc_clo(lam9405_fptr, 1);

//setting env list
clo9778[1] = decode_clo_array[2];
void* id_8973 = encode_clo(clo9778);



//creating new make-kont closure
void** clo9779 = alloc_kont(lam9395_spec, 1);

//setting env list
clo9779[1] = f_lam_9203;
void* f_lam_9209 = encode_clo(clo9779);



//clo-app
my_u45for_spec(my_u45for, f_lam_9209, int9475, decode_clo_array[3], id_8973);
}

inline void lam9415_fptr() // lam9415 -> generic version 
{
//reading env
void* const env9416 = arg_buffer[1];
//reading env and args
void* const id_8955 = arg_buffer[2];
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9416);

//if-clause
if(is_true(id_8955))
{
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(decode_clo_array[1])[0])(decode_clo_array[1], encode_str(new(GC) std::string("error")));
}
else
{

//creating new make-kont closure
void** clo9780 = alloc_kont(lam9413_spec, 3);

//setting env list
clo9780[1] = decode_clo_array[1];
clo9780[2] = decode_clo_array[2];
clo9780[3] = decode_clo_array[3];
void* f_lam_9210 = encode_clo(clo9780);



//creating new closure instance
void** clo9781 = alloc_clo(lam9393_fptr, 0);
void* id_8963 = encode_clo(clo9781);



//clo-app
make_u45matrix_spec(make_u45matrix, f_lam_9210, decode_clo_array[3], decode_clo_array[2], id_8963);
}

}

inline void lam9415_spec(void* env9416, void* id_8955) // lam9415 
{
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9416);

//if-clause
if(is_true(id_8955))
{
// kont-clo-app case
reinterpret_cast<void (*)(void*, void*)>(decode_clo(decode_clo_array[1])[0])(decode_clo_array[1], encode_str(new(GC) std::string("error")));
}
else
{

//creating new make-kont closure
void** clo9782 = alloc_kont(lam9413_spec, 3);

//setting env list
clo9782[1] = decode_clo_array[1];
clo9782[2] = decode_clo_array[2];
clo9782[3] = decode_clo_array[3];
void* f_lam_9210 = encode_clo(clo9782);



//creating new closure instance
void** clo9783 = alloc_clo(lam9393_fptr, 0);
void* id_8963 = encode_clo(clo9783);



//clo-app
make_u45matrix_spec(make_u45matrix, f_lam_9210, decode_clo_array[3], decode_clo_array[2], id_8963);
}

}

inline void lam9417_fptr() // lam9417 -> generic version 
{
//reading env
void* const env9418 = arg_buffer[1];
//reading env and args
void* const id_8952 = arg_buffer[2];
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9418);

//creating new make-kont closure
void** clo9784 = alloc_kont(lam9415_spec, 3);

//setting env list
clo9784[1] = decode_clo_array[1];
clo9784[2] = decode_clo_array[2];
clo9784[3] = decode_clo_array[3];
void* f_lam_9215 = encode_clo(clo9784);



//if-clause
if(is_true(id_8952))
{
// kont-clo-app case
lam9415_spec(f_lam_9215, bool_f9473);
}
else
{
// kont-clo-app case
lam9415_spec(f_lam_9215, bool_t9470);
}

}

inline void lam9417_spec(void* env9418, void* id_8952) // lam9417 
{
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9418);

//creating new make-kont closure
void** clo9785 = alloc_kont(lam9415_spec, 3);

//setting env list
clo9785[1] = decode_clo_array[1];
clo9785[2] = decode_clo_array[2];
clo9785[3] = decode_clo_array[3];
void* f_lam_9215 = encode_clo(clo9785);



//if-clause
if(is_true(id_8952))
{
// kont-clo-app case
lam9415_spec(f_lam_9215, bool_f9473);
}
else
{
// kont-clo-app case
lam9415_spec(f_lam_9215, bool_t9470);
}

}

inline void lam9419_fptr() // lam9419 -> generic version 
{
//reading env
void* const env9420 = arg_buffer[1];
//reading env and args
void* const id_8949 = arg_buffer[2];
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9420);

//creating new make-kont closure
void** clo9786 = alloc_kont(lam9417_spec, 3);

//setting env list
clo9786[1] = decode_clo_array[1];
clo9786[2] = decode_clo_array[2];
clo9786[3] = decode_clo_array[3];
void* f_lam_9216 = encode_clo(clo9786);



//if-clause
if(is_true(id_8949))
{

//creating new make-kont closure
void** clo9787 = alloc_kont(lam9385_spec, 1);

//setting env list
clo9787[1] = f_lam_9216;
void* f_lam_9217 = encode_clo(clo9787);



//clo-app
odd_u63_spec(odd_u63, f_lam_9217, decode_clo_array[2]);
}
else
{
// kont-clo-app case
lam9417_spec(f_lam_9216, bool_f9473);
}

}

inline void lam9419_spec(void* env9420, void* id_8949) // lam9419 
{
//decoding closure array
void** decode_clo_array = nullptr;
decode_clo_array = decode_clo(env9420);

//creating new make-kont closure
void** clo9788 = alloc_kont(lam9417_spec, 3);

//setting env list
clo9788[1] = decode_clo_array[1];
clo9788[2] = decode_clo_array[2];
clo9788[3] = decode_clo_array[3];
void* f_lam_9216 = encode_clo(clo9788);



//if-clause
if(is_true(id_8949))
{

//creating new make-kont closure
void** clo9789 = alloc_kont(lam9385_spec, 1);

//setting env list
clo9789[1] = f_lam_9216;
void* f_lam_9217 = encode_clo(clo9789);



//clo-app
odd_u63_spec(odd_u63, f_lam_9217, decode_clo_array[2]);
}
else
{
// kont-clo-app case
lam9417_spec(f_lam_9216, bool_f9473);
}

}

inline void make_u45maze_fptr() // make-maze -> generic version 
{
//reading env and args
void* const kont9200 = arg_buffer[2];
void* const n = arg_buffer[3];
void* const m = arg_buffer[4];
//decoding closure array
void** decode_clo_array = nullptr;

//creating new make-kont closure
void** clo9790 = alloc_kont(lam9419_spec, 3);

//setting env list
clo9790[1] = kont9200;
clo9790[2] = m;
clo9790[3] = n;
void* f_lam_9218 = encode_clo(clo9790);



//clo-app
odd_u63_spec(odd_u63, f_lam_9218, n);
}

inline void make_u45maze_spec(void* _9421, void* kont9200, void* n, void* m) // make-maze 
{
//decoding closure array
void** decode_clo_array = nullptr;

//creating new make-kont closure
void** clo9791 = alloc_kont(lam9419_spec, 3);

//setting env list
clo9791[1] = kont9200;
clo9791[2] = m;
clo9791[3] = n;
void* f_lam_9218 = encode_clo(clo9791);



//clo-app
odd_u63_spec(odd_u63, f_lam_9218, n);
}

inline void brouhaha_main_fptr() // brouhaha_main -> generic version 
{
//reading env and args
void* const kont9219 = arg_buffer[2];
//decoding closure array
void** decode_clo_array = nullptr;

//clo-app
make_u45maze_spec(make_u45maze, kont9219, int9477, int9477);
}

inline void brouhaha_main_spec(void* _9422, void* kont9219) // brouhaha_main 
{
//decoding closure array
void** decode_clo_array = nullptr;

//clo-app
make_u45maze_spec(make_u45maze, kont9219, int9477, int9477);
}

int main(int argc, char **argv)
{
mp_set_memory_functions(&allocate_function,
                            &reallocate_function,
                            &deallocate_function);

// initializing global constants in the main
int9475 = reinterpret_cast<void *>(encode_int(0));
int9452 = reinterpret_cast<void *>(encode_int(131072));
bool_t9470 = encode_bool(true);
int9468 = reinterpret_cast<void *>(encode_int(1));
bool_f9473 = encode_bool(false);
int9426 = reinterpret_cast<void *>(encode_int(2));
int9477 = reinterpret_cast<void *>(encode_int(11));
int9450 = reinterpret_cast<void *>(encode_int(3581));
int9451 = reinterpret_cast<void *>(encode_int(12751));



//making a call to the brouhaha main function to kick off our C++ emission.
void** f_halt_clo = alloc_kont(fhalt_spec, 0);
void* fhalt_clo = encode_clo(f_halt_clo);
arg_buffer[2] = fhalt_clo;

// calling next procedure using a function pointer
brouhaha_main_spec(nullptr, fhalt_clo);
}


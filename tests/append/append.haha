; ; ; #lang racket
(define (call lst lst2)
  ; (if (null? lst)
  ;     lst2
  ;     (cons (car lst) (call (cdr lst) lst2)))




  ; (car (list 1 2 3))
  ; (cdr (list 1 2 3))
  ; (cons 1 2)   
  ; (cons (cons 1 2) (cons 3 4)))

  ; (list 1 (cons 100 (list 1 (list 2))))

  ; (list (list (call (+ lst 1))))

  ; (append (list 1 2) (list 3 4))

  (append1 (list 200) (list 100)) 
  )


; ; (define (ok? row dist placed)
; ;   (if (null? placed)
; ;       #t
; ;       (and (not (= (car placed) (+ row dist)))
; ;            (not (= (car placed) (- row dist)))
; ;            (ok? row (+ dist 1) (cdr placed)))))

; ; (define (q-helper stack count)
; ;   (let* ((state (car stack))
; ;          (x (car state))
; ;          (y (car (cdr state)))
; ;          (z (car (cdr (cdr state)))))
; ;     (q-helper (cons (list (cdr x) (cons (car x) y) z)
; ;                     (if (ok? (car x) 1 z)
; ;                         (cons (list (append (cdr x) y) (list) (cons (car x) z))
; ;                               (cdr stack))
; ;                         (cdr stack)))
; ;               count)))
; ; #lang racket
; (define (iota1 n l)
;   ; (if (= n 0) l (iota1 (- n 1) (cons n l)))
;   (if (= n 0) l (iota1 (- n 1) (list n l)))
;   ; (if (= n 0) l (iota1 (- n 1) l))
;   ; (if (= n 0) l n)
;   ; n
;   )
  


; ; debug why using as instead of a1
; ; causes this non-termination issue.
; ;  (store (f-addr ctx "vcons") (list-of-vals [a0 as ...]))
; ; (specialized-prim "cons")
; ;   [(= e (apply (define-prim "cons" _) (fixedarg [a0 a1]) ctx kont _))
; ;   (store a1 (list-of-vals as))
; ;   -->
; ;   (store (f-addr ctx "vcons") (list-of-vals [a0 a1 ...]))
; ;   (ret (f-addr ctx "vcons") kont)]





; (define (nqueens n)
;   ; (q-helper (list (list (iota1 n (list)) (list) (list))) 0)
;   ; (list (list (iota1 n (list)) (list) (list)))
;   (if (= n 0) (list 500) (iota1 (- n 1) (list n (list))))
;   )

(define (brouhaha_main)
  ; (nqueens 2)
  ; (car (list (list 1 2) (list 3 4)))
  (call (list 1 2) (list 3 4))
  ; (cons (list 1 2) 3) 
  ; (cons 1 (list 2 3))
    
  )

; (define (ok? row dist placed)
;   (if (null? placed)
;       #t
;       (and (not (= (car placed) (+ row dist)))
;            (not (= (car placed) (- row dist)))
;            (ok? row (+ dist 1) (cdr placed)))))

; (define (q-helper stack count)
;   (if (null? stack)
;       count
;       (let* ((state (car stack))
;              (x (car state))
;              (y (car (cdr state)))
;              (z (car (cdr (cdr state)))))

;         (cond
;           [(null? x)
;            (if (null? y)
;                (q-helper (cdr stack) (+ count 1))
;                (q-helper (cdr stack) count))]
;           [else
;            (q-helper (cons (list (cdr x) (cons (car x) y) z)
;                             (if (ok? (car x) 1 z)
;                                 (cons (list (append (cdr x) y) (list) (cons (car x) z))
;                                       (cdr stack))
;                                 (cdr stack)))
;                     count)])
;         )))

; (define (iota1 n l)
;   (if (= n 0) l (iota1 (- n 1) (cons n l))))

; (define (nqueens n)
;   (q-helper (list (list (iota1 n (list)) (list) (list))) 0)
;   )

; (define (brouhaha_main)
;   (nqueens 2))

; (brouhaha_main)    


;----------------------------------------------------------------------;
;;;;;;;;;;;;;;;;;;;;;;;;;APPENDED PROGRAM ABOVE;;;;;;;;;;;;;;;;;;;;;;;;;
;----------------------------------------------------------------------;
;;;;;;;;;;;;;;;;;;;;;;;;;ANALYSIS PROGRAM BELOW;;;;;;;;;;;;;;;;;;;;;;;;;
;----------------------------------------------------------------------;


;----------------------------------------------------------------------;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;FREE VARIABLES;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;----------------------------------------------------------------------;
; (non-list-value ?(addr _))
; (non-list-value ?(s-addr _))
; (non-list-value ?(f-addr _ _))
; (non-list-value ?(quote _))
(non-list-value ?(symbol _))
(non-list-value ?(bool _))
(non-list-value ?(int _))
(non-list-value ?(string _))
(non-list-value ?(state _))


; (non-list-value (or (addr _) (quote _) (string _) (bool _) (state _)))

;REF VARIABLES
(free x ?(ref x))

;LAMBDAS
[(free x eb)
 (=/= y x)
 -->
 (free x ?(lambda (varparam y) eb))]

[(free x eb)
 -->
 (do-free-lam ?(lambda (fixedparam ys) eb) ys x)]

[(do-free-lam lam [y ys ...] x)
 (=/= y x)
 -->
 (do-free-lam lam ys x)]

[(do-free-lam lam [] x)
 -->
 (free x lam)]

;APPL
[(or (free x ef) (free x ea))
 -->
 (free x ?(appl ef ea))]

;IF EXPRESSIONS
[(or (free x guard) (free x tExp) (free x fExp))
 -->
 (free x ?(if guard tExp fExp))]

;APP
[(free x ef)
 -->
(free x ?(app ef eas))]

(do-free-app ?(app ef eas) eas)

[(do-free-app app [ea eas ...])
 -->
 (do-free-app app eas)
 [(free x ea)
  -->
  (free x app)]]


;LET BINDINGS RIGHT HAND SIDES
(do-free-let-rhs ?(let binds body) binds)

[(do-free-let-rhs let [bind binds ...])
 -->
(do-free-let-rhs let binds)]    

[(do-free-let-rhs let [(binding lhs rhs) binds ...])
 (free x rhs)
 -->
 (free x let)]

;LET BINDINGS LEFT HAND SIDES
[(free x body)
 -->
(do-free-let-lhs ?(let binds body) binds x)]

[(do-free-let-lhs let [(binding lhs rhs) binds ...] x)
 (=/= lhs x)
 -->
 (do-free-let-lhs let binds x)]

[(do-free-let-lhs let [] x)
 -->
 (free x let)]



;----------------------------------------------------------------------;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;START RULE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;----------------------------------------------------------------------;
[(define "brouhaha_main" (fixedparam []) body)
 -->
 (eval body [] (halt))]

(tick ?(do-tick [] call) [call]) 
; (tick ?(do-tick [x] call) [call x])
; (tick ?(do-tick [x y] call) [call x y])
; (tick ?(do-tick [x y z] call) [call x y])


;----------------------------------------------------------------------;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EVAL CASES;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;----------------------------------------------------------------------;
;BASE PRIMITIVE TYPES
[(eval (symbol val) env kont)
 -->
 (store (f-addr env (symbol val)) (symbol-val val))
 (ret (f-addr env (symbol val)) kont)]

[(eval (bool val) env kont)
 -->
 (store (f-addr env (bool val)) (bool-val val))
 (ret (f-addr env (bool val)) kont)]

[(eval (int val) env kont)
 -->
 (store (f-addr env (int val)) (int-val val))
 (ret (f-addr env (int val)) kont)]

[(eval (string val) env kont)
 -->
 (store (f-addr env (string val)) (string-val val))
 (ret (f-addr env (string val)) kont)]

[(eval (state val) env kont)
 -->
 (store (f-addr env (state val)) (state-val val))
 (ret (f-addr env (state val)) kont)]

;FUNCTION AND VARIABLE REFERENCES
[(eval (ref x) env kont)
 -->
 (ret (f-addr env x) kont)]

;LAMBDA AND FUNC
[(eval e env kont)
 (= e (lambda _ _))
 -->
 (store (f-addr env e) (clo e env))
 (ret (f-addr env e) kont)]
        
;APP AND APPLY
[(eval call env kont)
 (= call (app ef [eas ...]))
 -->
 (eval ef env (appk call [] eas env kont))]

[(eval call env kont)
 (= call (appl ef ea))
 -->
 (eval ef env (applak call ea env kont))]

;IF CASE
[(eval (if guard tExp fExp) env kont)
 -->
 (eval guard env (if-k tExp fExp env kont))]

;LET CASE
[(eval call env kont)
 (= call (let [(binding lhs rhs) bind-rest ...] body))
 -->
 (eval rhs env (letk call body [lhs] [] bind-rest env kont))]

;---------------------------------------------------------------------;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;RET CASES;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;---------------------------------------------------------------------;
;LAMBDA AND FUNC
[(ret a (appk call [as ...] [ea0 ea-rest ...] env kont))
 -->
 (eval ea0 env (appk call [as ... a] [ea-rest ...] env kont))]

[(ret a (appk call [af as ...] [] env kont))
 (store af vf)
 -->
 (apply vf (fixedarg [as ... a]) env kont call)]

[(ret af (appk call [] [] env kont))
 (store af vf)
 -->
 (apply vf (fixedarg []) env kont call)]

[(ret af (applak call ea env kont))
 -->
 (eval ea env (applfk call af env kont))]

[(ret a (applfk call af env kont))
 (store af vf)
 -->
 (apply vf (vararg a) env kont call)]

[(ret a (k-addr eb))
 -->
 (ret a {store (k-addr eb)})]

;IF CASES
[(ret ga (if-k tExp fExp env kont))
 (store ga (bool "t"))
 --> 
 (eval tExp env kont)]

[(ret ga (if-k tExp fExp env kont))
 (store ga (bool "f"))
 --> 
 (eval fExp env kont)]

[(ret (s-addr _) (if-k tExp fExp env kont))
 --> 
 (eval tExp env kont)
 (eval fExp env kont)]

;LET CASE
[(ret a (letk call body [xs ...] [as ...] [(binding lhs rhs) bind-rest ...] env kont))
 -->
 (eval rhs env (letk call body [xs ... lhs] [as ... a] bind-rest env kont))]

[(ret a (letk call body [xs ...] [as ...] [] envlet kont))
 -->
 (= envtick {tick !(do-tick envlet call)})
 (store (k-addr body) kont)
 (do-fixed-prop-all envlet xs [as ... a])
 (eval body envtick (k-addr body))]




;---------------------------------------------------------------------;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;APPLY CASES;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;---------------------------------------------------------------------;
;DEFINE --> CLOSURE
[(apply (define fname params body) args env kont call)
 --> 
 (apply (clo (lambda params body) []) args env kont call)]  

;DEFINE-PRIM HANDLING (NOT SPECIALIZED)
[(= e (apply (define-prim fname _) args _ kont _))
 (~ specialized-prim fname)
 -->
 (store (s-addr e) (state e))
 (ret (s-addr e) kont)]

;SPECIALIZED PRIMS
(specialized-prim "cons")
  [(= e (apply (define-prim "cons" _) (fixedarg [a0 a1]) env kont _))
  (store a1 (list-of-vals as))
  -->
  (store (f-addr env e) (list-of-vals [a0 as ...]))
  (ret (f-addr env e) kont)]

  [(= e (apply (define-prim "cons" _) (fixedarg [a0 a1]) env kont _))
  (store a1 val)
  (non-list-value val)
  -->
  (store (f-addr env e) (list-of-vals [a0 a1]))
  (ret (f-addr env e) kont)]

  ;VARIADIC
  [(= e (apply (define-prim "cons" _) (vararg a) env kont call))
  (store a (list-of-vals as))
  --> 
  (do-store-addr-union (f-addr env e) as [])
  (ret (f-addr env e) kont)]

  ;When the next address points to a list-of-vals
  [(do-store-addr-union addr [a as ...] [union-as ...])
  (store a (list-of-vals under-as))
  -->
  (do-store-addr-union addr as [a under-as ... union-as ...])]

  ;When the next address points to a single addr
  [(do-store-addr-union addr [a as ...] [union-as ...])
  (store a val)
  (non-list-value val)
  -->
  (do-store-addr-union addr as [a union-as])]
 
  [(do-store-addr-union addr [] [union-as ...])
  -->
  (store addr (list-of-vals union-as))]


(specialized-prim "null?")
  [(= e (apply (define-prim "null?" _) (fixedarg [a]) env kont _))
   (store a (list-of-vals as))
   (= as [])
   -->
   (store (f-addr env e) (bool "t"))]

  [(= e (apply (define-prim "null?" _) (fixedarg [a]) env kont _))
   (store a (list-of-vals [a0 as ...]))
   -->
   (store (f-addr env e) (bool "t"))
   (store (f-addr env e) (bool "f"))]


(specialized-prim "car")
 [(= e (apply (define-prim "car" _) (fixedarg [a]) env kont _))
  (store a (list-of-vals [_ ... ai _ ...]))
  -->
  (store (f-addr env e) ai)
  (ret (f-addr env e) kont)]

(specialized-prim "cdr")
 [(= e (apply (define-prim "cdr" _) (fixedarg [a]) env kont _))
  (store a (list-of-vals as))
   -->
  (store (f-addr env e) (list-of-vals as))
  (ret (f-addr env e) kont)]

(specialized-prim "list")
 [(= e (apply (define-prim "list" _) (fixedarg as) env kont _))
  -->
  (store (f-addr env e) (list-of-vals as))
  (ret (f-addr env e) kont)]

 [(= e (apply (define-prim "list" _) (vararg a) env kont _))
  (store a (list-of-vals as))
  -->
  (store (f-addr env e) (list-of-vals as))
  (ret (f-addr env e) kont)]




;FIXED ARG
[(apply (clo (lambda (fixedparam [xs ...]) eb) envlam) (fixedarg [as ...]) envcall kont call)
 --> 
 (store (k-addr eb) kont)
 (= envtick {tick !(do-tick envcall call)})
 (do-fixed-prop-all envtick xs as)
 (eval eb envlam (k-addr eb))
 [(free y eb)
  -->
  (store-flow (f-addr envtick y) (f-addr envlam y))]]

[(apply (clo (lambda (varparam x) eb) envlam) (fixedarg [as ...]) envcall kont call)
 --> 
 (store (k-addr eb) kont)
 (= envtick {tick !(do-tick envcall call)})     
 (store (f-addr envtick x) (list-of-vals as))
 (eval eb envlam (k-addr eb))
 [(free y eb) 
  -->
  (store-flow (f-addr envtick y) (f-addr envlam y))]]

;VARIADIC ARG
[(apply (clo (lambda (varparam x) eb) envlam) (vararg a) envcall kont call)
 --> 
 (store (k-addr eb) kont)
 (= envtick {tick !(do-tick envcall call)})
 (store-flow a (f-addr envtick x))
 (eval eb envlam (k-addr eb))
 [(free y eb)
  -->
  (store-flow (f-addr envtick y) (f-addr envlam y))]]

[(apply (clo (lambda (fixedparam [xs ...]) eb) envlam) (vararg a) envcall kont call)
 (store a (list-of-vals as))
 -->
 (store (k-addr eb) kont)
 (= envtick {tick !(do-tick envcall call)})
 (do-var-prop-all envtick xs as)
 (eval eb envlam (k-addr eb))
 [(free y eb)
  -->
  (store-flow (f-addr envtick y) (f-addr envlam y))]]





;----------------------------------------------------------------------;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;HELPER FUNCTIONS;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;----------------------------------------------------------------------;
;DO-VIXED-PROP-ALL
[(do-fixed-prop-all envtick [x x-rest ...] [a a-rest ...])
 -->
 (do-fixed-prop-all envtick x-rest a-rest)
 (store-flow a (f-addr envtick x))]


;DO-VAR-PROP-ALL
[(do-var-prop-all envtick [x x-rest ...] [a a-rest ...])
 -->
 (do-var-prop-all-h envtick [x x-rest ...] [a a-rest ...] [a a-rest ...])]

[(do-var-prop-all-h envtick [x x-rest ...] [a a-rest ...] a-old)
 -->
 (do-var-prop-all-h envtick [x x-rest ...] a-rest a-old)
 (store-flow a (f-addr envtick x))]


[(do-var-prop-all-h envtick [x x-rest ...] [] a-old)
 -->
 (do-var-prop-all-h envtick x-rest a-old a-old)]

;STORE-FLOW
[(store a v)
 (store-flow a a1)
 -->
 (store a1 v)]


 ;----------------------------------------------------------------------;
;;;;;;;;;;;;;;;;;;;;;;;;;;Inlinable Callsite Detection;;;;;;;;;;;;;;;;;;
;----------------------------------------------------------------------;
[(eval exp _ _)
(= exp (app (ref func) _))
(store (f-addr _ func) (define-prim dp_func _))
(count store (f-addr _ func) (define-prim dp_func _) cnt)
 -->
(inlinable-call exp func dp_func cnt)]

[(inlinable-call exp func dp_func cnt)
-->
(is-inlinable-call exp func dp_func {maximum inlinable-call exp func dp_func} {prim-count dp_func})]


[(eval exp _ _)
(= exp (app lam _))
(= lam (lambda var body))
(free x lam)
;(store (k-addr _ func) (define-prim _ _))
;(count store (f-addr _ func) (define-prim _ _) cnt)
 -->
(is-combinator-call lam x)]


 (answer ?(ret (s-addr a) (halt)) {store (s-addr a)})
 (answer ?(ret (f-addr _ a) (halt)) {store (f-addr _ a)})
 




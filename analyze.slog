

;----------------------------------------------------------------------;
;;;;;;;;;;;;;;;;;;;;;;;;;APPENDED PROGRAM ABOVE;;;;;;;;;;;;;;;;;;;;;;;;;
;----------------------------------------------------------------------;
;;;;;;;;;;;;;;;;;;;;;;;;;ANALYSIS PROGRAM BELOW;;;;;;;;;;;;;;;;;;;;;;;;;
;----------------------------------------------------------------------;


;----------------------------------------------------------------------;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;FREE VARIABLES;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;----------------------------------------------------------------------;
;REF VARIABLES
(free x ?(ref x))

;LAMBDAS (NOT COMPLETE)
[(free x eb)
 (=/= x y)
 -->
 (free x ?(lambda y eb))]

;APPL
[(or (free x ef) (free x ea))
 -->
 (free x ?(appl ef ea))]

;IF EXPRESSIONS
[(or (free x guard) (free x tExp) (free x fExp))
 -->
 (free x ?(if guard tExp fExp))]

;APP
[(free x ef)
 -->
 (free x ?(app ef eas))]

(do-free ?(app ef eas) eas)

[(do-free app [ea eas ...])
 -->
 (do-free app eas)]

[(do-free app [ea eas ...])
 (= app (app ef _))
 (free x ea)
 -->
 (free x app)]
 

;----------------------------------------------------------------------;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;START RULE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;----------------------------------------------------------------------;
[(define "brouhaha_main" (fixedparam []) body)
 -->
 (eval body [] (halt))]

(tick ?(do-tick [] call) [call]) 
; (tick ?(do-tick [x] call) [call x])
; (tick ?(do-tick [x y] call) [call x y])
; (tick ?(do-tick [x y z] call) [call x y])


;----------------------------------------------------------------------;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EVAL CASES;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;----------------------------------------------------------------------;
;BASE PRIMITIVE TYPES
[(eval (quote dat) env kont)
 -->
 (store (addr (quote dat)) dat)
 (ret (addr (quote dat)) kont)]

[(eval (string str) env kont)
 -->
 (store (addr (string str)) (string str))
 (ret (addr (string str)) kont)]

;FUNCTION AND VARIABLE REFERENCES
[(eval (ref x) env kont)
 -->
 (ret {store (addr env x)} kont)]

;LAMBDA AND FUNC
[(eval e env kont)
 (= e (lambda _ _))
 -->
 (store (addr e) (clo e env))
 (ret (addr e) kont)]

;APP AND APPLY
[(eval call env kont)
 (= call (app ef [eas ...]))
 -->
 (eval ef env (appk call [] eas env kont))]

[(eval call env kont)
 (= call (appl ef ea))
 -->
 (eval ef env (applak call ea env kont))]

;IF CASE
[(eval (if guard tExp fExp) env kont)
 -->
 (eval guard env (if-k tExp fExp env kont))]

;LET CASE
[(eval (let [(binding lhs rhs) bind-rest ...] body) env kont)
 -->
 (eval rhs env (letk body [lhs] [] bind-rest env kont))]

; ;APPLY-PRIM CASE
; [(= e (eval (apply-prim op lst) env kont))
;  -->
;  (store (saddr e) (state e))
;  (ret (saddr e) kont)]

; ;PRIM CASE
; [(= e (eval (prim op [lst ...]) env kont))
;  -->
;  (store (saddr e) (state e))
;  (ret (saddr e) kont)]

;  [(or
;     (= e (eval (apply-prim op lst) env kont))
;     (= e (eval (prim op [lst ...]) env kont)))
;  -->
;  (store (saddr e) (state e))
;  (ret (saddr e) kont)]

;  [(= e (eval (prim op [lst ...]) env kont))
;   -->
;   (store (saddr e) (state e))
;   (ret (saddr e) kont)]


;---------------------------------------------------------------------;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;RET CASES;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;---------------------------------------------------------------------;
;LAMBDA AND FUNC
[(ret a (appk call [as ...] [ea0 ea-rest ...] env kont))
 -->
 (eval ea0 env (appk call [as ... a] [ea-rest ...] env kont))]

[(ret a (appk call [af as ...] [] env kont))
 (store af vf)
 -->
 (apply call env vf (fixedarg [as ... a]) kont)]

[(ret af (appk call [] [] env kont))
 (store af vf)
 -->
 (apply call env vf (fixedarg []) kont)]

[(ret af (applak call ea env kont))
 -->
 (eval ea env (applfk call af kont))]

[(ret a (applfk call af kont))
 (store af vf)
 -->
 (apply call vf (vararg a) kont)]

[(ret a (kaddr eb))
 -->
 (ret a {store (kaddr eb)})]

;IF CASES
[(ret ga (if-k tExp fExp env kont))
 (store ga (bool "t"))
 --> 
 (eval tExp env kont)]

[(ret ga (if-k tExp fExp env kont))
 (store ga (bool "f"))
 --> 
 (eval fExp env kont)]

[(ret (saddr _) (if-k tExp fExp env kont))
 --> 
 (eval tExp env kont)
 (eval fExp env kont)]

;LET CASE
[(ret a (letk body [xs ...] [as ...] [(binding lhs rhs) bind-rest ...] env kont))
 -->
 (eval rhs env (letk body [xs ... lhs] [as ... a] bind-rest env kont))]

[(ret a (letk body [xs ...] [as ...] [] envlet kont))
 -->
 (store (kaddr body) kont)
 (do-fixed-prop-all xs [as ... a])
 (eval body {ext-all !(do-ext-all envlet xs)} (kaddr body))]




;---------------------------------------------------------------------;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;APPLY CASES;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;---------------------------------------------------------------------;
;DEFINE --> CLOSURE
[(apply call (define fname params body) args kont)
 --> 
 (apply call (clo (lambda params body) {top-level-env}) args kont)]

;DEFINE-PRIM HANDLING
 [(= e (apply _ (define-prim fname params) args kont))
 -->
 (store (saddr e) (state e))
 (ret (saddr e) kont)]


;FIXED ARG
[(apply call env (clo (lambda (fixedparam [xs ...]) eb) envlam) (fixedarg [as ...]) kont)
 --> 
 (store (kaddr eb) kont)
 (do-fixed-prop-all xs as)
 (eval eb {ext-all !(do-ext-all envlam xs)} (kaddr eb))]

 [(apply call env (clo (lambda (varparam x) eb) envlam) (fixedarg [as ...]) kont)
 --> 
 (store (kaddr eb) kont)
 (store (addr x) (list-of as))
 (= envtick {tick !(do-tick env e)})
 (eval eb envtick (kaddr eb))]
;store-flow (envlam x) to (envtick x)

 ;VARIADIC ARG
[(apply call (clo (lambda (varparam x) eb) envlam) (vararg a) kont)
 --> 
 (store (kaddr eb) kont)
 (store-flow a (addr x))
 (eval eb {ext-all !(do-ext-all envlam [x])} (kaddr eb))]

[(apply call (clo (lambda (fixedparam [xs ...]) eb) envlam) (vararg a) kont)
 (store a (list-of as))
 --> 
 (store (kaddr eb) kont)
 (do-var-prop-all xs as)
 (eval eb {ext-all !(do-ext-all envlam xs)} (kaddr eb))]



;----------------------------------------------------------------------;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;HELPER FUNCTIONS;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;----------------------------------------------------------------------;
;DO-EXT-ALL/EXT-ALL
[-->
 (ext-all ?(do-ext-all env [x x-rest ...])
          {ext-all !(do-ext-all (env-set env x (addr x)) x-rest)})]

(ext-all ?(do-ext-all env []) env)


;DO-VIXED-PROP-ALL
[(do-fixed-prop-all [x x-rest ...] [a a-rest ...])
 -->
 (do-fixed-prop-all x-rest a-rest)
 (store-flow a (addr x))]


;DO-VAR-PROP-ALL
[(do-var-prop-all [x x-rest ...] [a a-rest ...])
 -->
 (do-var-prop-all-h [x x-rest ...] [a a-rest ...] [a a-rest ...])]

[(do-var-prop-all-h [x x-rest ...] [a a-rest ...] a-old)
 -->
 (do-var-prop-all-h [x x-rest ...] a-rest a-old)
 (store-flow a (addr x))]


[(do-var-prop-all-h [x x-rest ...] [] a-old)
 -->
 (do-var-prop-all-h x-rest a-old a-old)]

;STORE-FLOW
[(store a v)
 (store-flow a a1)
 -->
 (store a1 v)]

;ENV HANDLING
(env-map ?(env-set env x addr) x addr)


[(=/= x y)
 (env-set _ y _)
 -->
 (env-map ?(env-set env x _) y {env-map env y})]


 (answer ?(ret (addr a) (halt)) {store (addr a)})
 (answer ?(ret (saddr a) (halt)) {store (saddr a)})
 



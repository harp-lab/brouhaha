;----------------------------------------------------------------------;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;START RULE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;----------------------------------------------------------------------;
[(define "brouhaha_main" (fixedparam []) body)
 -->
 (eval body {top-level-env} (halt))]




;----------------------------------------------------------------------;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EVAL CASES;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;----------------------------------------------------------------------;
;BASE PRIMITIVE TYPES
[(eval (quote dat) env kont)
 -->
 (ret dat kont)]

;FUNCTION AND VARIABLE REFERENCES
[(eval (ref x) env kont)
 -->
 (ret {store {env-map env x}} kont)]

;LAMBDA AND FUNC
[(eval (lambda (fixedparam [xs ...]) eb) env kont)
 -->
 (ret (clo (lambda (fixedparam [xs ...]) eb) env) kont)]

;APP AND APPLY
[(eval (app ef [eas ...]) env kont)
 -->
 (eval ef env (appk [] [eas ...] env kont))]

[(eval (appl ef ea) env kont)
 -->
 (eval ef env (ar ea env kont))]

;IF CASE
[(eval (if guard tExp fExp) env kont)
 -->
 (eval guard env (if-k tExp fExp env kont))]

 ;LET CASE
 [(eval (let [(binding lhs rhs) bind-rest ...] body) env kont)
  -->
  (eval rhs env (letk body [lhs] [] bind-rest env kont))]




;---------------------------------------------------------------------;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;RET CASES;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;---------------------------------------------------------------------;
;LAMBDA AND FUNC
[(ret v (appk [vs ...] [ea0 ea-rest ...] env kont))
 -->
 (eval ea0 env (appk [vs ... v] [ea-rest ...] env kont))]

[(ret v (appk [vf vs ...] [] env kont))
 -->
 (apply vf [vs ... v] kont)]

[(ret vf (appk [] [] env kont))
 -->
 (apply vf [] kont)]

;APPLY CASE
[(ret vf (ar ea env kont))
 -->
 (eval ea env (fn vf kont))]

[(ret va (fn vf kont))
 -->
 (apply vf va kont)]

[(ret v (kaddr eb))
 -->
 (ret v {store (kaddr eb)})]

;IF CASES
[(ret (bool "t") (if-k tExp fExp env kont))
 --> 
 (eval tExp env kont)]

[(ret (bool "f") (if-k tExp fExp env kont))
 --> 
 (eval fExp env kont)]

;LET CASE
[(ret v (letk body [xs ...] [vs ...] [(binding lhs rhs) bind-rest ...] env kont))
 -->
 (eval rhs env (letk body [xs ... lhs] [vs ... v] bind-rest env kont))]

[(ret v (letk body [xs ...] [vs ...] [] envlet kont))
 -->
 (store (kaddr body) kont)
 (eval body {ext-all !(do-ext-all envlet xs [vs ... v])} (kaddr body))]




;---------------------------------------------------------------------;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;APPLY CASES;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;---------------------------------------------------------------------;
;FIXED PARAM
[(apply (clo (lambda (fixedparam [xs ...]) eb) envlam) [vs ...] kont)
 --> 
 (store (kaddr eb) kont)
 (eval eb {ext-all !(do-ext-all envlam xs vs)} (kaddr eb))]

[(apply (define fname (fixedparam [args ...]) body) [vs ...] kont)
 --> 
 (store (kaddr body) kont)
 (eval body {ext-all !(do-ext-all {top-level-env} args vs)} (kaddr body))]

 ;VARIADIC PARAM
[(apply (clo (lambda (varparam lstx) eb) envlam) [vs ...] kont)
 --> 
 (store (kaddr eb) kont)
 (eval eb {ext-all !(do-ext-all envlam [lstx] [vs])} (kaddr eb))]

[(apply (define fname (varparam lstx) body) [vs ...] kont)
 --> 
 (store (kaddr body) kont)
 (eval body {ext-all !(do-ext-all {top-level-env} [lstx] [vs])} (kaddr body))]




;----------------------------------------------------------------------;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;HELPER FUNCTIONS;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;----------------------------------------------------------------------;
;DO-EXT-ALL/EXT-ALL
[-->
 (ext-all ?(do-ext-all env [x x-rest ...] [v v-rest ...])
          {ext-all !(do-ext-all (env-set env x (addr x)) x-rest v-rest)})
 (store (addr x) v)]

(ext-all ?(do-ext-all env [] []) env)




;ENV HANDLING
(env-map ?(env-set env x val) x val)

[(=/= x y)
 (env-set _ y _) ;;could also do (ref y)
 -->
 (env-map ?(env-set env x _) y {env-map env y})]




;----------------------------------------------------------------------;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;PRIM FUNCTIONS;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;----------------------------------------------------------------------;
;LIST
(store (addr "list") (define "list" (fixedparam)))




;----------------------------------------------------------------------;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;TEST CASES;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;----------------------------------------------------------------------;
;LAMBDA APPLICATION CASE
; (store (addr "brouhaha_main") (define "brouhaha_main" (fixedparam []) (app (lambda (fixedparam ["a5737""b5738"]) (ref "b5738")) [(quote (int "5"))(quote (int "6"))])))
; (top-level-env (env-set (empty) "brouhaha_main" (addr "brouhaha_main")))

;FUNCTION CALL/APPLICATION CASE
; (store (addr "call") (define "call" (fixedparam ["num1""num2"]) (if (quote (bool "f")) (ref "num1") (ref "num2"))))
; (store (addr "brouhaha_main") (define "brouhaha_main" (fixedparam []) (app (ref "call") [(quote (int "1"))(quote (int "2"))])))
; (top-level-env (env-set (env-set (empty) "brouhaha_main" (addr "brouhaha_main")) "call" (addr "call")))

;NO ARGUMENT FUNCTION CALL
; (store (addr "call") (define "call" (fixedparam []) (if (quote (bool "f")) (quote (int "1")) (quote (int "2")))))
; (store (addr "brouhaha_main") (define "brouhaha_main" (fixedparam []) (app (ref "call") [])))
; (top-level-env (env-set (env-set (empty) "brouhaha_main" (addr "brouhaha_main")) "call" (addr "call")))

;LET CASE
; (store (addr "call") (define "call" (fixedparam ["num1""num2"]) (let [ (binding "x83113" (ref "num1")) (binding "y83114" (ref "num2"))] (ref "x83113"))))
; (store (addr "brouhaha_main") (define "brouhaha_main" (fixedparam []) (app (ref "call") [(quote (const "5"))(quote (const "42"))])))
; (top-level-env (env-set (env-set (empty) "brouhaha_main" (addr "brouhaha_main")) "call" (addr "call")))

;VARIADIC APPLY
(store (addr "call") (define "call" (fixedparam []) (appl (ref "+") (app (ref "list") [(quote (int "1"))(quote (int "2"))(quote (int "3"))]))))
(store (addr "brouhaha_main") (define "brouhaha_main" (fixedparam []) (app (ref "call") [])))
(top-level-env (env-set (env-set (env-set (env-set (env-set (env-set (env-set (env-set (env-set (env-set (env-set (env-set (env-set (env-set (env-set (env-set (env-set (env-set (env-set (env-set (env-set (env-set (env-set (env-set (env-set (env-set (env-set (env-set (env-set (env-set (env-set (env-set (env-set (env-set (env-set (env-set (env-set (env-set (empty) "brouhaha_main" (addr "brouhaha_main")) "call" (addr "call")) "hash-count" (addr "hash-count")) "hash-has-key?" (addr "hash-has-key?")) "hash-set" (addr "hash-set")) "hash-ref" (addr "hash-ref")) "hash" (addr "hash")) "append" (addr "append")) "foldr" (addr "foldr")) "drop" (addr "drop")) "filter" (addr "filter")) "map" (addr "map")) "length" (addr "length")) "take" (addr "take")) "take-helper" (addr "take-helper")) "reverse" (addr "reverse")) "reverse-helper" (addr "reverse-helper")) "foldl" (addr "foldl")) "member?" (addr "member?")) "list" (addr "list")) "odd?" (addr "odd?")) "even?" (addr "even?")) "cdr" (addr "cdr")) "car" (addr "car")) "cons" (addr "cons")) "eq?" (addr "eq?")) "equal?" (addr "equal?")) "null?" (addr "null?")) ">=" (addr ">=")) "<=" (addr "<=")) "<" (addr "<")) ">" (addr ">")) "=" (addr "=")) "/" (addr "/")) "modulo" (addr "modulo")) "*" (addr "*")) "-" (addr "-")) "+" (addr "+")))#<void>



;----------------------------------------------------------------------;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;START RULE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;----------------------------------------------------------------------;
[(define "brouhaha_main" (fixedparam []) body)
 -->
 (eval body {top-level-env} (halt))]




;----------------------------------------------------------------------;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EVAL CASES;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;----------------------------------------------------------------------;
;BASE PRIMITIVES
[(eval (const x) env kont)
 -->
 (ret (const x) kont)]

[(eval (bool x) env kont)
 -->
 (ret (bool x) kont)]

;FUNCTION AND VARIABLE REFERENCES
[(eval (ref x) env kont)
 (=/= {store {env-map env x}} (define fname (fixedparam [args ...]) body))
 -->
 (ret {store {env-map env x}} kont)]

 [(eval (ref x) env kont)
 (= {store {env-map env x}} (define fname (fixedparam [args ...]) body))
 -->
 (eval (func (fixedparam args) body) env kont)]

;LAMBDA AND FUNC
[(eval (lambda (fixedparam [xs ...]) eb) env kont)
 -->
 (ret (clo (lambda (fixedparam [xs ...]) eb) env) kont)]

[(eval (func (fixedparam [args ...]) body) env kont)
 -->
 (ret (clo (func (fixedparam args) body) env) kont)]

;APP AND APPLY
[(eval (app ef [eas ...]) env kont)
 -->
 (eval ef env (appk [] [eas ...] env kont))]

[(eval (appl ef ea) env kont)
 -->
 (eval ef env (ar ea env kont))]

;IF CASE
[(eval (if guard tExp fExp) env kont)
 -->
 (eval guard env (if-k tExp fExp env kont))]

 ;LET CASE
 [(eval (let [bindings ...] body) env kont)
  -->
  ()]




;---------------------------------------------------------------------;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;RET CASES;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;---------------------------------------------------------------------;
[(ret v (appk [vs ...] [ea0 ea-rest ...] env kont))
 -->
 (eval ea0 env (appk [vs ... v] [ea-rest ...] env kont))]

[(ret v (appk [vf vs ...] [] env kont))
 -->
 (apply vf [vs ... v] kont)]

[(ret vf (ar ea env kont))
 -->
 (eval ea env (fn vf kont))]

[(ret va (fn vf kont))
 -->
 (apply vf va kont)]

[(ret v (kaddr eb))
 -->
 (ret v {store (kaddr eb)})]

;if case
[(ret (bool "t") (if-k tExp fExp env kont))
 --> 
 (eval tExp env kont)]

[(ret (bool "f") (if-k tExp fExp env kont))
 --> 
 (eval fExp env kont)]




;---------------------------------------------------------------------;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;APPLY CASES;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;---------------------------------------------------------------------;
[(apply (clo (lam x eb) envlam) va kont)
 -->
 (store (addr x) va)
 (store (kaddr eb) kont)
 (eval eb (env-set envlam x (addr x)) (kaddr eb))]


;(apply (clo (lambda (fixedparam ($lst x ($nil 0))) (ref x))
; (env-set (empty ) brouhaha_main (addr brouhaha_main))) 
; ($lst (const 42) ($nil 0)) (halt ))
[(apply (clo (lambda (fixedparam [xs ...]) eb) envlam) [vs ...] kont)
 (ext-semi !(do-ext-all envlam xs vs) envlam)
 --> 
 (store (kaddr eb) kont)
 (eval eb {ext-all (do-ext-all env [] [])} (kaddr eb))]


; (apply (clo (func (fixedparam ($lst num ($nil 0))) (ref num)) 
; (env-set (env-set (empty ) brouhaha_main (addr brouhaha_main)) call (addr call))) 
; ($lst (const 42) ($nil 0)) (halt ))
[(apply (clo (func (fixedparam [args ...]) body) envfunc) [vs ...] kont)
 (ext-semi !(do-ext-all envfunc args vs) envfunc)
 --> 
 (store (kaddr body) kont)
 (eval body {ext-all (do-ext-all env [] [])} (kaddr body))]

;(ext-all (do-ext-all (env-set (env-set (empty ) brouhaha_main (addr brouhaha_main)) x (addr x)) ($nil 0) ($nil 0)) (env-set (env-set (empty ) brouhaha_main (addr brouhaha_main)) x (addr x)))




;----------------------------------------------------------------------;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;HELPER FUNCTIONS;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;----------------------------------------------------------------------;
 [(do-ext-all env [x x-rest ...] [v v-rest ...])
 -->
 (store (addr x) v)
 (do-ext-all (env-set env x (addr x)) x-rest v-rest)]
 
 (ext-semi ?(do-ext-all env _ _) env)
 (ext-all ?(do-ext-all env [] []) env)



;ENV HANDLING
(env-map ?(env-set env x val) x val)

[(=/= x y)
 (env-set _ y _) ;;could also do (ref y)
 -->
 (env-map ?(env-set env x _) y {env-map env y})]




;----------------------------------------------------------------------;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;TEST CASES;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;----------------------------------------------------------------------;
;LAMBDA APPLICATION CASE
; (store (addr "call") (define "call" (fixedparam ["num"]) (ref "num")))
; (store (addr "brouhaha_main") (define "brouhaha_main" (fixedparam []) (app (ref "call") [(const "42")])))
; (top-level-env (env-set (env-set (empty) "brouhaha_main" (addr "brouhaha_main")) "call" (addr "call")))

;FUNCTION CALL/APPLICATION CASE
; (store (addr "call") (define "call" (fixedparam ["num1""num2"]) (if (bool "f") (ref "num1") (ref "num2"))))
; (store (addr "brouhaha_main") (define "brouhaha_main" (fixedparam []) (app (ref "call") [(const "1")(const "2")])))
; (top-level-env (env-set (env-set (empty) "brouhaha_main" (addr "brouhaha_main")) "call" (addr "call")))

;LET CASE
(store (addr "call") (define "call" (fixedparam []) (let [ (binding "x82714" (quote 5)) (binding "y82715" (quote 42))] (ref "x82714"))))
(store (addr "brouhaha_main") (define "brouhaha_main" (fixedparam []) (app (ref "call") [])))
(top-level-env (env-set (env-set (empty) "brouhaha_main" (addr "brouhaha_main")) "call" (addr "call")))
;----------------------------------------------------------------------;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;START RULE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;----------------------------------------------------------------------;
[(define "brouhaha_main" (fixedparam []) body)
 -->
 (eval body {top-level-env} (halt))]




;----------------------------------------------------------------------;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EVAL CASES;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;----------------------------------------------------------------------;
;BASE PRIMITIVE TYPES
[(eval (quote dat) env kont)
 -->
 (ret dat kont)]

;FUNCTION AND VARIABLE REFERENCES
[(eval (ref x) env kont)
 -->
 (ret {store {env-map env x}} kont)]

;LAMBDA AND FUNC
[(eval (lambda (fixedparam [xs ...]) eb) env kont)
 -->
 (ret (clo (lambda (fixedparam [xs ...]) eb) env) kont)]

;APP AND APPLY
[(eval (app ef [eas ...]) env kont)
 -->
 (eval ef env (appk [] [eas ...] env kont))]

[(eval (appl ef ea) env kont)
 -->
 (eval ef env (ar ea env kont))]

;IF CASE
[(eval (if guard tExp fExp) env kont)
 -->
 (eval guard env (if-k tExp fExp env kont))]

 ;LET CASE
 [(eval (let [(binding lhs rhs) bind-rest ...] body) env kont)
  -->
  (eval rhs env (letk body [lhs] [] bind-rest env kont))]




;---------------------------------------------------------------------;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;RET CASES;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;---------------------------------------------------------------------;
;LAMBDA AND FUNC
[(ret v (appk [vs ...] [ea0 ea-rest ...] env kont))
 -->
 (eval ea0 env (appk [vs ... v] [ea-rest ...] env kont))]

[(ret v (appk [vf vs ...] [] env kont))
 -->
 (apply vf [vs ... v] kont)]

;APPLY CASE
[(ret vf (ar ea env kont))
 -->
 (eval ea env (fn vf kont))]

[(ret va (fn vf kont))
 -->
 (apply vf va kont)]

[(ret v (kaddr eb))
 -->
 (ret v {store (kaddr eb)})]

;IF CASES
[(ret (bool "t") (if-k tExp fExp env kont))
 --> 
 (eval tExp env kont)]

[(ret (bool "f") (if-k tExp fExp env kont))
 --> 
 (eval fExp env kont)]

;LET CASE
[(ret v (letk body [xs ...] [vs ...] [(binding lhs rhs) bind-rest ...] env kont))
 -->
 (eval rhs env (letk body [xs ... lhs] [vs ... v] bind-rest env kont))]

[(ret v (letk body [xs ...] [vs ...] [] envlet kont))
 -->
 (store (kaddr body) kont)
 (eval body {ext-all !(do-ext-all envlet xs [vs ... v])} (kaddr body))]




;---------------------------------------------------------------------;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;APPLY CASES;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;---------------------------------------------------------------------;
[(apply (clo (lam x eb) envlam) va kont)
 -->
 (store (addr x) va)
 (store (kaddr eb) kont)
 (eval eb (env-set envlam x (addr x)) (kaddr eb))]


;(apply (clo (lambda (fixedparam ($lst x ($nil 0))) (ref x))
; (env-set (empty ) brouhaha_main (addr brouhaha_main))) 
; ($lst (const 42) ($nil 0)) (halt ))
; [(apply (clo (lambda (fixedparam [xs ...]) eb) envlam) [vs ...] kont)
;  (ext-semi !(do-ext-all envlam xs vs) envlam)
;  --> 
;  (store (kaddr eb) kont)
;  (eval eb {ext-all (do-ext-all env [] [])} (kaddr eb))]

 [(apply (clo (lambda (fixedparam [xs ...]) eb) envlam) [vs ...] kont)
 --> 
 (store (kaddr eb) kont)
 (eval eb {ext-all !(do-ext-all envlam xs vs)} (kaddr eb))]


; (apply (clo (func (fixedparam ($lst num ($nil 0))) (ref num)) 
; (env-set (env-set (empty ) brouhaha_main (addr brouhaha_main)) call (addr call))) 
; ($lst (const 42) ($nil 0)) (halt ))
[(apply (define fname (fixedparam [args ...]) body) [vs ...] kont)
 --> 
 (store (kaddr body) kont)
 (eval body {ext-all !(do-ext-all {top-level-env} args vs)} (kaddr body))]

;(ext-all (do-ext-all (env-set (env-set (empty ) brouhaha_main (addr brouhaha_main)) x (addr x)) ($nil 0) ($nil 0)) (env-set (env-set (empty ) brouhaha_main (addr brouhaha_main)) x (addr x)))




;----------------------------------------------------------------------;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;HELPER FUNCTIONS;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;----------------------------------------------------------------------;
;DO-EXT-ALL/EXT-ALL
[-->
 (ext-all ?(do-ext-all env [x x-rest ...] [v v-rest ...])
          {ext-all !(do-ext-all (env-set env x (addr x)) x-rest v-rest)})
 (store (addr x) v)]

(ext-all ?(do-ext-all env [] []) env)




;ENV HANDLING
(env-map ?(env-set env x val) x val)

[(=/= x y)
 (env-set _ y _) ;;could also do (ref y)
 -->
 (env-map ?(env-set env x _) y {env-map env y})]




;----------------------------------------------------------------------;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;TEST CASES;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;----------------------------------------------------------------------;
;LAMBDA APPLICATION CASE
; (store (addr "brouhaha_main") (define "brouhaha_main" (fixedparam []) (app (lambda (fixedparam ["a5737""b5738"]) (ref "b5738")) [(quote (int "5"))(quote (int "6"))])))
; (top-level-env (env-set (empty) "brouhaha_main" (addr "brouhaha_main")))

;FUNCTION CALL/APPLICATION CASE
; (store (addr "call") (define "call" (fixedparam ["num1""num2"]) (if (quote (bool "f")) (ref "num1") (ref "num2"))))
; (store (addr "brouhaha_main") (define "brouhaha_main" (fixedparam []) (app (ref "call") [(quote (int "1"))(quote (int "2"))])))
; (top-level-env (env-set (env-set (empty) "brouhaha_main" (addr "brouhaha_main")) "call" (addr "call")))

;NO ARGUMENT FUNCTION CALL
(store (addr "call") (define "call" (fixedparam []) (if (quote (bool "f")) (quote (int "1")) (quote (int "2")))))
(store (addr "brouhaha_main") (define "brouhaha_main" (fixedparam []) (app (ref "call") [])))
(top-level-env (env-set (env-set (empty) "brouhaha_main" (addr "brouhaha_main")) "call" (addr "call")))

;LET CASE
; (store (addr "call") (define "call" (fixedparam ["num1""num2"]) (let [ (binding "x83113" (ref "num1")) (binding "y83114" (ref "num2"))] (ref "x83113"))))
; (store (addr "brouhaha_main") (define "brouhaha_main" (fixedparam []) (app (ref "call") [(quote (const "5"))(quote (const "42"))])))
; (top-level-env (env-set (env-set (empty) "brouhaha_main" (addr "brouhaha_main")) "call" (addr "call")))


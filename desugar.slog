; small step rules require you to implement a stack
; Control Env Kontinuations machine
; (e, env, 'mt) -> CEK state -> CEK state -> ....... -> (v, env, 'mt)
; (x, p, k) -> lookup in p for x
; (x, p, k) -> (p(x), k)
; ((lam (x) eb), p, k) -> (<((lam (x) eb), p), k)
; ((ef, ea), p, k) -> (ef, p, <ea, p, k>)
;                                      -> (vf, (ea, p, k)) -> (ea, p, <vf, k>)
;                                                                           -> (va, (vf, k)) -> (vf, va, k)
; (<(lam (x) eb), px>, va, k) -> (eb, p[x -> va], k)



;IMPLEMENTING IF
;(if cond true false)
;;  eval cond and put true and false as kont frames (with their own pointers)
;;

; TEST CASES
;(eval (app (lam "x" (ref "x")) (lam "y" (ref "y"))) (empty) (halt))

;(eval (app (lam "x" (app (ref "x") (lam "c" (ref "c")))) (lam "z" (ref "z"))) (empty) (halt))
;;((lam (x) (x (lam (c) c))) (lam (z) z))

; (eval (app (lam "x" (ref "x")) (const 1)) (empty) (halt))
;(eval (if (bool "f") (const 1) (const 0)))
;(eval (if (if (bool "t") (bool "f") (bool "t")) (const 1) (app (lam "x" (ref "x")) (lam "y" (ref "y")))))
;(prim "+" [(const 1) (const 2)]) ;-> (const 3)
; (prims op ["+" "-" "*" "/"])

;(U (lam "x" (app (ref "x") (ref "x"))))
; (Y (app {U} 
;     (lam "y" 
;         (lam "f" 
;             (app (ref "f") (lam "x" 
;                 (app (app (app {U} (ref "y")) (ref "f")) (ref "x"))))))))

; (eval   (app {Y} 
;             (lam "z" 
;                 (lam "c" 
;                     (if {== (ref "c") (const 0)}
;                         (const 1) 
;                         (app (mult (ref "c") 
;                              (app (ref "z") 
;                                 (app (minus (ref "c") (const 1)))
;                                     )))))) (const 5))))

;(eval (app {U} {U}))
;(eval {Y})
;(eval (app (lam "x" (ref "x")) (lam "y" (ref "y"))))



;---------------------------------------------------------------------------------;
;                                      NOTES                                      ;
;---------------------------------------------------------------------------------;



[(define "brouhaha_main" (fixedparam []) body)
 -->
 (eval body {top-level-env} (halt))]




; ;EVAL CASES
; ;This is the injection function (allows you to just eval the expression without manually adding (empty) and (halt))
; [(eval exp)
;  -->
;  (eval exp (empty) (halt))]

;numbers
[(eval (const x) env kont)
 -->
 (ret (const x) kont)]

;boolean
[(eval (bool x) env kont)
 -->
 (ret (bool x) kont)]

;if case
[(eval (if guard tExp fExp) env kont)
 -->
 (eval guard env (if-k tExp fExp env kont))]

[(eval (ref x) env kont)
 -->
 (varfunc? )]

 ;(ret {store {env-map env x}} kont)

[(eval (lambda (fixedparam [xs ...]) eb) env kont)
 -->
 (ret (clo (lambda (fixedparam [xs ...]) eb) env) kont)]

[(eval (func (fixedparam [args ...]) body) env kont)
 -->
 (ret (clo (func (fixedparam args) body) env) kont)]

[(eval (app ef [eas ...]) env kont)
 -->
 (eval ef env (appk [] [eas ...] env kont))]

[(eval (appl ef ea) env kont)
 -->
 (eval ef env (ar ea env kont))]





;RET CASES
[(ret (define fname (fixedparam [args ...]) body) kont)
 -->
 (eval (func (fixedparam args) body) {top-level-env} kont)]

[(ret v (appk [vs ...] [ea0 ea-rest ...] env kont))
 -->
 (eval ea0 env (appk [vs ... v] [ea-rest ...] env kont))]

[(ret v (appk [vf vs ...] [] env kont))
 -->
 (apply vf [vs ...] kont)]

[(ret vf (ar ea env kont))
 -->
 (eval ea env (fn vf kont))]

[(ret va (fn vf kont))
 -->
 (apply vf va kont)]

[(ret v (kaddr eb))
 -->
 (ret v {store (kaddr eb)})]

;if case
[(ret (bool "t") (if-k tExp fExp env kont))
 --> 
 (eval tExp env kont)]

[(ret (bool "f") (if-k tExp fExp env kont))
 --> 
 (eval fExp env kont)]





;APPLY CASES
[(apply (clo (lam x eb) envlam) va kont)
 -->
 (store (addr x) va)
 (store (kaddr eb) kont)
 (eval eb (env-set envlam x (addr x)) (kaddr eb))]

[(apply (clo (lambda (fixedparam [xs ...]) eb) envlam) [vs ...] kont)
 --> 
 (store (kaddr eb) kont)
 (eval eb {ext-all !(do-ext-all envlam xs vs)} (kaddr eb))]

[(apply (clo (func (fixedparam [args ...]) body) envfunc) [vs ...] kont)
 --> 
 (store (kaddr body) kont)
 (eval body {ext-all !(do-ext-all envfunc args vs)} (kaddr body))]


 ;DO-EXT-ALL
 [(do-ext-all env [x x-rest ...] [v v-rest ...])
 -->
 (store (addr x) v)
 (do-ext-all (env-set env x (addr x)) x-rest v-rest)]
 
 (ext-all ?(do-ext-all env [] []) env)




;ENV HANDLING
(env-map ?(env-set env x val) x val)

[(=/= x y)
 (env-set _ y _) ;;could also do (ref y)
 -->
 (env-map ?(env-set env x _) y {env-map env y})]


(store (addr "call") (define "call" (fixedparam []) (const "42")))
(store (addr "brouhaha_main") (define "brouhaha_main" (fixedparam []) (app (ref "call") [])))
(top-level-env (env-set (env-set (empty) "brouhaha_main" (addr "brouhaha_main")) "call" (addr "call")))
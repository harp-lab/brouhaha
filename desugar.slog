;----------------------------------------------------------------------;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;START RULE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;----------------------------------------------------------------------;
[(define "brouhaha_main" (fixedparam []) body)
 -->
 (eval body {top-level-env} (halt))]




;----------------------------------------------------------------------;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EVAL CASES;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;----------------------------------------------------------------------;
;BASE PRIMITIVE TYPES
[(eval (quote dat) env kont)
 -->
 (ret dat kont)]

;FUNCTION AND VARIABLE REFERENCES
[(eval (ref x) env kont)
 (=/= {store {env-map env x}} (define fname (fixedparam [args ...]) body))
 -->
 (ret {store {env-map env x}} kont)]

 [(eval (ref x) env kont)
 (= {store {env-map env x}} (define fname (fixedparam [args ...]) body))
 -->
 (eval (func (fixedparam args) body) env kont)]

;LAMBDA AND FUNC
[(eval (lambda (fixedparam [xs ...]) eb) env kont)
 -->
 (ret (clo (lambda (fixedparam [xs ...]) eb) env) kont)]

[(eval (func (fixedparam [args ...]) body) env kont)
 -->
 (ret (clo (func (fixedparam args) body) env) kont)]

;APP AND APPLY
[(eval (app ef [eas ...]) env kont)
 -->
 (eval ef env (appk [] [eas ...] env kont))]

[(eval (appl ef ea) env kont)
 -->
 (eval ef env (ar ea env kont))]

;IF CASE
[(eval (if guard tExp fExp) env kont)
 -->
 (eval guard env (if-k tExp fExp env kont))]

 ;LET CASE
 [(eval (let [(binding lhs rhs) bind-rest ...] body) env kont)
  -->
  (eval rhs env (letk body [lhs] [] bind-rest env kont))]




;---------------------------------------------------------------------;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;RET CASES;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;---------------------------------------------------------------------;
;LAMBDA AND FUNC
[(ret v (appk [vs ...] [ea0 ea-rest ...] env kont))
 -->
 (eval ea0 env (appk [vs ... v] [ea-rest ...] env kont))]

[(ret v (appk [vf vs ...] [] env kont))
 -->
 (apply vf [vs ... v] kont)]

;APPLY CASE
[(ret vf (ar ea env kont))
 -->
 (eval ea env (fn vf kont))]

[(ret va (fn vf kont))
 -->
 (apply vf va kont)]

[(ret v (kaddr eb))
 -->
 (ret v {store (kaddr eb)})]

;IF CASES
[(ret (bool "t") (if-k tExp fExp env kont))
 --> 
 (eval tExp env kont)]

[(ret (bool "f") (if-k tExp fExp env kont))
 --> 
 (eval fExp env kont)]

;LET CASE
[(ret v (letk body [xs ...] [vs ...] [(binding lhs rhs) bind-rest ...] env kont))
 -->
 (eval rhs env (letk body [xs ... lhs] [vs ... v] bind-rest env kont))]

[(ret v (letk body [xs ...] [vs ...] [] envlet kont))
 (ext-semi !(do-ext-all envlet xs [vs ... v]) env)
 -->
 (store (kaddr body) kont)
 (eval body {ext-all (do-ext-all env [] [])} (kaddr body))]




;---------------------------------------------------------------------;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;APPLY CASES;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;---------------------------------------------------------------------;
[(apply (clo (lam x eb) envlam) va kont)
 -->
 (store (addr x) va)
 (store (kaddr eb) kont)
 (eval eb (env-set envlam x (addr x)) (kaddr eb))]


;(apply (clo (lambda (fixedparam ($lst x ($nil 0))) (ref x))
; (env-set (empty ) brouhaha_main (addr brouhaha_main))) 
; ($lst (const 42) ($nil 0)) (halt ))
; [(apply (clo (lambda (fixedparam [xs ...]) eb) envlam) [vs ...] kont)
;  (ext-semi !(do-ext-all envlam xs vs) envlam)
;  --> 
;  (store (kaddr eb) kont)
;  (eval eb {ext-all (do-ext-all env [] [])} (kaddr eb))]

 [(apply (clo (lambda (fixedparam [xs ...]) eb) envlam) [vs ...] kont)
 --> 
 (store (kaddr eb) kont)
 (eval eb {ext-all !(do-ext-all envlam xs vs)} (kaddr eb))]


; (apply (clo (func (fixedparam ($lst num ($nil 0))) (ref num)) 
; (env-set (env-set (empty ) brouhaha_main (addr brouhaha_main)) call (addr call))) 
; ($lst (const 42) ($nil 0)) (halt ))
[(apply (clo (func (fixedparam [args ...]) body) envfunc) [vs ...] kont)
 (ext-semi !(do-ext-all envfunc args vs) envfunc)
 --> 
 (store (kaddr body) kont)
 (eval body {ext-all (do-ext-all env [] [])} (kaddr body))]

;(ext-all (do-ext-all (env-set (env-set (empty ) brouhaha_main (addr brouhaha_main)) x (addr x)) ($nil 0) ($nil 0)) (env-set (env-set (empty ) brouhaha_main (addr brouhaha_main)) x (addr x)))




;----------------------------------------------------------------------;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;HELPER FUNCTIONS;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;----------------------------------------------------------------------;
;  [(do-ext-all env [x x-rest ...] [v v-rest ...])
;  -->
;  (store (addr x) v)
;  (do-ext-all (env-set env x (addr x)) x-rest v-rest)]
 
 ;(ext-semi ?(do-ext-all env _ _) env)

;;REWRITE
[-->
 (ext-all ?(do-ext-all env [x x-rest ...] [v v-rest ...])
          {ext-all !(do-ext-all (env-set env x (addr x)) x-rest v-rest)})
 (store (addr x) v)]

(ext-all ?(do-ext-all env [] []) env)




;ENV HANDLING
(env-map ?(env-set env x val) x val)

[(=/= x y)
 (env-set _ y _) ;;could also do (ref y)
 -->
 (env-map ?(env-set env x _) y {env-map env y})]




;----------------------------------------------------------------------;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;TEST CASES;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;----------------------------------------------------------------------;
;LAMBDA APPLICATION CASE
(store (addr "lam") (define "lam" (fixedparam ["x""y"]) (app (lambda (fixedparam ["a5737""b5738"]) (ref "b5738")) [(ref "x")(ref "y")])))
(store (addr "brouhaha_main") (define "brouhaha_main" (fixedparam []) (app (ref "lam") [(quote (int "5"))(quote (int "6"))])))
(top-level-env (env-set (env-set (empty) "brouhaha_main" (addr "brouhaha_main")) "lam" (addr "lam")))

;FUNCTION CALL/APPLICATION CASE
; (store (addr "call") (define "call" (fixedparam ["num1""num2"]) (if (bool "f") (ref "num1") (ref "num2"))))
; (store (addr "brouhaha_main") (define "brouhaha_main" (fixedparam []) (app (ref "call") [(const "1")(const "2")])))
; (top-level-env (env-set (env-set (empty) "brouhaha_main" (addr "brouhaha_main")) "call" (addr "call")))

;LET CASE
; (store (addr "call") (define "call" (fixedparam ["num1""num2"]) (let [ (binding "x83113" "num1") (binding "y83114" "num2")] (ref "x83113"))))
; (store (addr "brouhaha_main") (define "brouhaha_main" (fixedparam []) (app (ref "call") [(quote (const "5"))(quote (const "42"))])))
; (top-level-env (env-set (env-set (empty) "brouhaha_main" (addr "brouhaha_main")) "call" (addr "call")))